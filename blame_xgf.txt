d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000    1) /*
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000    2)  * Copyright (C) 2017 MediaTek Inc.
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000    3)  *
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000    4)  * This program is free software: you can redistribute it and/or modify
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000    5)  * it under the terms of the GNU General Public License version 2 as
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000    6)  * published by the Free Software Foundation.
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000    7)  *
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000    8)  * This program is distributed in the hope that it will be useful,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000    9)  * but WITHOUT ANY WARRANTY; without even the implied warranty of
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   10)  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   11)  * GNU General Public License for more details.
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   12)  *
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   13)  * You should have received a copy of the GNU General Public License
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   14)  * along with this program. If not, see <http://www.gnu.org/licenses/>.
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   15)  */
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   16) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   17) #include <linux/mutex.h>
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   18) #include <linux/slab.h>
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   19) #include <linux/rbtree.h>
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   20) #include <linux/preempt.h>
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   21) #include <linux/proc_fs.h>
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   22) #include <linux/vmalloc.h>
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   23) #include <linux/mm.h>
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   24) #include <linux/module.h>
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   25) #include <linux/sched/clock.h>
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   26) #include <linux/cpumask.h>
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   27) #include <linux/sched/task.h>
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   28) #include <linux/sched/cputime.h>
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   29) #include <linux/bitops.h>
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   30) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   31) #include <mt-plat/fpsgo_common.h>
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   32) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   33) #include <trace/events/fpsgo.h>
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   34) #include <trace/events/sched.h>
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   35) #include <trace/events/ipi.h>
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   36) #include <trace/events/irq.h>
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   37) #include <trace/events/timer.h>
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   38) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   39) #include "xgf.h"
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   40) #include "fpsgo_base.h"
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   41) #include "fpsgo_sysfs.h"
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   42) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   43) static DEFINE_MUTEX(xgf_main_lock);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   44) static int xgf_enable;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   45) static int xgf_ko_ready;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   46) static struct kobject *xgf_kobj;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   47) static unsigned long long last_check2recycle_ts;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   48) static atomic_t xgf_atomic_val_0 = ATOMIC_INIT(0);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   49) static atomic_t xgf_atomic_val_1 = ATOMIC_INIT(0);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   50) static unsigned long long last_update2spid_ts;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   51) static char *xgf_sp_name = SP_ALLOW_NAME;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   52) static int xgf_extra_sub;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   53) static int xgf_force_no_extra_sub;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   54) static int cur_xgf_extra_sub;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   55) static int xgf_dep_frames = XGF_DEP_FRAMES_MIN;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   56) static int xgf_prev_dep_frames = XGF_DEP_FRAMES_MIN;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   57) static int xgf_spid_sub = XGF_DO_SP_SUB;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   58) static int xgf_ema_dividend = EMA_DIVIDEND;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   59) static int xgf_spid_ck_period = NSEC_PER_SEC;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   60) static int xgf_sp_name_id;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   61) static int xgf_uboost = XGF_UBOOST;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   62) static int xgf_stddev_multi = XGF_UBOOST_STDDEV_M;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   63) static int xgf_spid_list_length;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   64) static int xgf_wspid_list_length;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   65) static int xgf_cfg_spid;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   66) int fstb_frame_num;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   67) EXPORT_SYMBOL(fstb_frame_num);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   68) int fstb_no_stable_thr;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   69) EXPORT_SYMBOL(fstb_no_stable_thr);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   70) int fstb_no_stable_multiple;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   71) EXPORT_SYMBOL(fstb_no_stable_multiple);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   72) int fstb_no_stable_multiple_eara;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   73) EXPORT_SYMBOL(fstb_no_stable_multiple_eara);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   74) int fstb_is_eara_active;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   75) EXPORT_SYMBOL(fstb_is_eara_active);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   76) int fstb_can_update_thr;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   77) EXPORT_SYMBOL(fstb_can_update_thr);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   78) int fstb_target_fps_margin_low_fps;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   79) EXPORT_SYMBOL(fstb_target_fps_margin_low_fps);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   80) int fstb_target_fps_margin_high_fps;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   81) EXPORT_SYMBOL(fstb_target_fps_margin_high_fps);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   82) int fstb_separate_runtime_enable;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   83) EXPORT_SYMBOL(fstb_separate_runtime_enable);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   84) int fstb_fps_num;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   85) EXPORT_SYMBOL(fstb_fps_num);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   86) int fstb_fps_choice[10] = {20, 25, 30, 40, 45, 60, 90, 120, 144, 240};
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   87) EXPORT_SYMBOL(fstb_fps_choice);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   88) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   89) module_param(xgf_sp_name, charp, 0644);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   90) module_param(xgf_extra_sub, int, 0644);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   91) module_param(xgf_force_no_extra_sub, int, 0644);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   92) module_param(xgf_dep_frames, int, 0644);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   93) module_param(xgf_spid_sub, int, 0644);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   94) module_param(xgf_ema_dividend, int, 0644);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   95) module_param(xgf_spid_ck_period, int, 0644);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   96) module_param(xgf_sp_name_id, int, 0644);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   97) module_param(xgf_uboost, int, 0644);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   98) module_param(xgf_stddev_multi, int, 0644);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000   99) module_param(xgf_cfg_spid, int, 0644);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  100) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  101) HLIST_HEAD(xgf_renders);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  102) HLIST_HEAD(xgf_hw_events);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  103) HLIST_HEAD(xgf_spid_list);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  104) HLIST_HEAD(xgf_wspid_list);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  105) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  106) int (*xgf_est_runtime_fp)(
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  107) 	pid_t r_pid,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  108) 	struct xgf_render *render,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  109) 	unsigned long long *runtime,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  110) 	unsigned long long ts
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  111) 	);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  112) EXPORT_SYMBOL(xgf_est_runtime_fp);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  113) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  114) int (*fpsgo_xgf2ko_calculate_target_fps_fp)(
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  115) 	int pid,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  116) 	unsigned long long bufID,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  117) 	int *target_fps_margin,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  118) 	unsigned long long cur_dequeue_start_ts,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  119) 	unsigned long long cur_queue_end_ts
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  120) 	);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  121) EXPORT_SYMBOL(fpsgo_xgf2ko_calculate_target_fps_fp);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  122) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  123) void (*fpsgo_xgf2ko_do_recycle_fp)(
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  124) 	int pid,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  125) 	unsigned long long bufID
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  126) 	);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  127) EXPORT_SYMBOL(fpsgo_xgf2ko_do_recycle_fp);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  128) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  129) static int (*xgf_stat_xchg_fp)(int enable);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  130) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  131) int (*xgff_est_runtime_fp)(
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  132) 	pid_t r_pid,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  133) 	struct xgf_render *render,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  134) 	unsigned long long *runtime,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  135) 	unsigned long long ts
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  136) 	);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  137) EXPORT_SYMBOL(xgff_est_runtime_fp);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  138) int (*xgff_update_start_prev_index_fp)(struct xgf_render *render);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  139) EXPORT_SYMBOL(xgff_update_start_prev_index_fp);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  140) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  141) long long (*xgf_ema2_predict_fp)(struct xgf_ema2_predictor *pt, long long X);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  142) EXPORT_SYMBOL(xgf_ema2_predict_fp);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  143) void (*xgf_ema2_init_fp)(struct xgf_ema2_predictor *pt);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  144) EXPORT_SYMBOL(xgf_ema2_init_fp);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  145) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  146) void xgff_clean_deps_list(struct xgf_render *render, int pos)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  147) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  148) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  149) EXPORT_SYMBOL(xgff_clean_deps_list);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  150) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  151) int xgff_dep_frames_mod(struct xgf_render *render, int pos)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  152) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  153) 	return 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  154) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  155) EXPORT_SYMBOL(xgff_dep_frames_mod);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  156) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  157) struct xgf_dep *xgff_get_dep(
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  158) 	pid_t tid, struct xgf_render *render, int pos, int force)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  159) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  160) 	return NULL;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  161) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  162) EXPORT_SYMBOL(xgff_get_dep);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  163) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  164) static inline void xgf_lock(const char *tag)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  165) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  166) 	mutex_lock(&xgf_main_lock);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  167) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  168) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  169) static inline void xgf_unlock(const char *tag)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  170) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  171) 	mutex_unlock(&xgf_main_lock);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  172) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  173) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  174) void xgf_lockprove(const char *tag)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  175) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  176) 	WARN_ON(!mutex_is_locked(&xgf_main_lock));
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  177) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  178) EXPORT_SYMBOL(xgf_lockprove);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  179) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  180) static int xgf_tracepoint_probe_register(struct tracepoint *tp,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  181) 					void *probe,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  182) 					void *data)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  183) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  184) 	return tracepoint_probe_register(tp, probe, data);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  185) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  186) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  187) static int xgf_tracepoint_probe_unregister(struct tracepoint *tp,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  188) 					void *probe,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  189) 					void *data)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  190) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  191) 	return tracepoint_probe_unregister(tp, probe, data);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  192) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  193) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  194) void xgf_trace(const char *fmt, ...)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  195) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  196) 	char log[256];
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  197) 	va_list args;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  198) 	int len;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  199) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  200) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  201) 	va_start(args, fmt);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  202) 	len = vsnprintf(log, sizeof(log), fmt, args);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  203) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  204) 	if (unlikely(len == 256))
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  205) 		log[255] = '\0';
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  206) 	va_end(args);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  207) 	trace_xgf_log(log);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  208) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  209) EXPORT_SYMBOL(xgf_trace);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  210) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  211) void *xgf_alloc(int i32Size)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  212) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  213) 	void *pvBuf;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  214) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  215) 	if (i32Size <= PAGE_SIZE)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  216) 		pvBuf = kzalloc(i32Size, GFP_ATOMIC);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  217) 	else
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  218) 		pvBuf = vzalloc(i32Size);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  219) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  220) 	return pvBuf;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  221) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  222) EXPORT_SYMBOL(xgf_alloc);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  223) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  224) void xgf_free(void *pvBuf)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  225) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  226) 	kvfree(pvBuf);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  227) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  228) EXPORT_SYMBOL(xgf_free);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  229) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  230) void *xgf_atomic_val_assign(int select)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  231) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  232) 	if (!select)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  233) 		return (void *)(&xgf_atomic_val_0);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  234) 	else
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  235) 		return (void *)(&xgf_atomic_val_1);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  236) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  237) EXPORT_SYMBOL(xgf_atomic_val_assign);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  238) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  239) int *xgf_extra_sub_assign(void)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  240) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  241) 	return (int *)(&cur_xgf_extra_sub);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  242) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  243) EXPORT_SYMBOL(xgf_extra_sub_assign);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  244) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  245) int *xgf_spid_sub_assign(void)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  246) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  247) 	return (int *)(&xgf_spid_sub);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  248) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  249) EXPORT_SYMBOL(xgf_spid_sub_assign);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  250) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  251) int xgf_atomic_read(atomic_t *val)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  252) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  253) 	return atomic_read(val);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  254) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  255) EXPORT_SYMBOL(xgf_atomic_read);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  256) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  257) int xgf_atomic_inc_return(atomic_t *val)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  258) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  259) 	return atomic_inc_return(val);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  260) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  261) EXPORT_SYMBOL(xgf_atomic_inc_return);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  262) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  263) void xgf_atomic_set(atomic_t *val, int i)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  264) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  265) 	atomic_set(val, i);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  266) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  267) EXPORT_SYMBOL(xgf_atomic_set);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  268) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  269) unsigned int xgf_cpumask_next(int cpu,  const struct cpumask *srcp)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  270) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  271) 	return cpumask_next(cpu, srcp);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  272) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  273) EXPORT_SYMBOL(xgf_cpumask_next);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  274) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  275) int xgf_num_possible_cpus(void)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  276) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  277) 	return num_possible_cpus();
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  278) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  279) EXPORT_SYMBOL(xgf_num_possible_cpus);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  280) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  281) int xgf_get_task_wake_cpu(struct task_struct *t)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  282) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  283) 	return t->wake_cpu;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  284) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  285) EXPORT_SYMBOL(xgf_get_task_wake_cpu);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  286) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  287) int xgf_get_task_pid(struct task_struct *t)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  288) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  289) 	return t->pid;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  290) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  291) EXPORT_SYMBOL(xgf_get_task_pid);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  292) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  293) long xgf_get_task_state(struct task_struct *t)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  294) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  295) 	return t->state;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  296) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  297) EXPORT_SYMBOL(xgf_get_task_state);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  298) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  299) static inline int xgf_ko_is_ready(void)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  300) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  301) 	xgf_lockprove(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  302) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  303) 	return xgf_ko_ready;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  304) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  305) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  306) int xgf_get_display_rate(void)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  307) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  308) 	return 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  309) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  310) EXPORT_SYMBOL(xgf_get_display_rate);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  311) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  312) int xgf_get_process_id(int pid)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  313) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  314) 	return -EINVAL;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  315) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  316) EXPORT_SYMBOL(xgf_get_process_id);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  317) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  318) int xgf_check_main_sf_pid(int pid, int process_id)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  319) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  320) 	return 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  321) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  322) EXPORT_SYMBOL(xgf_check_main_sf_pid);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  323) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  324) int xgf_check_specific_pid(int pid)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  325) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  326) 	return 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  327) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  328) EXPORT_SYMBOL(xgf_check_specific_pid);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  329) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  330) static inline int xgf_is_enable(void)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  331) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  332) 	xgf_lockprove(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  333) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  334) 	return xgf_enable;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  335) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  336) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  337) unsigned long long xgf_get_time(void)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  338) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  339) 	unsigned long long temp;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  340) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  341) 	preempt_disable();
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  342) 	temp = cpu_clock(smp_processor_id());
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  343) 	preempt_enable();
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  344) 	return temp;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  345) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  346) EXPORT_SYMBOL(xgf_get_time);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  347) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  348) int set_xgf_spid_list(char *proc_name,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  349) 		char *thrd_name, int action)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  350) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  351) 	struct xgf_spid *new_xgf_spid;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  352) 	int retval = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  353) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  354) 	xgf_lock(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  355) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  356) 	if (!strncmp("0", proc_name, 1) &&
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  357) 			!strncmp("0", thrd_name, 1)) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  358) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  359) 		struct xgf_spid *iter;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  360) 		struct hlist_node *t;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  361) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  362) 		hlist_for_each_entry_safe(iter, t, &xgf_spid_list, hlist) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  363) 			hlist_del(&iter->hlist);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  364) 			xgf_free(iter);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  365) 		}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  366) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  367) 		xgf_spid_list_length = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  368) 		goto out;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  369) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  370) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  371) 	if (xgf_spid_list_length >= XGF_MAX_SPID_LIST_LENGTH) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  372) 		retval = -ENOMEM;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  373) 		goto out;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  374) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  375) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  376) 	new_xgf_spid = xgf_alloc(sizeof(*new_xgf_spid));
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  377) 	if (!new_xgf_spid) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  378) 		retval = -ENOMEM;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  379) 		goto out;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  380) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  381) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  382) 	if (!strncpy(new_xgf_spid->process_name, proc_name, 16)) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  383) 		xgf_free(new_xgf_spid);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  384) 		retval = -ENOMEM;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  385) 		goto out;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  386) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  387) 	new_xgf_spid->process_name[15] = '\0';
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  388) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  389) 	if (!strncpy(new_xgf_spid->thread_name,	thrd_name, 16)) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  390) 		xgf_free(new_xgf_spid);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  391) 		retval = -ENOMEM;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  392) 		goto out;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  393) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  394) 	new_xgf_spid->thread_name[15] = '\0';
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  395) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  396) 	new_xgf_spid->pid = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  397) 	new_xgf_spid->rpid = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  398) 	new_xgf_spid->tid = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  399) 	new_xgf_spid->bufID = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  400) 	new_xgf_spid->action = action;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  401) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  402) 	hlist_add_head(&new_xgf_spid->hlist, &xgf_spid_list);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  403) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  404) 	xgf_spid_list_length++;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  405) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  406) out:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  407) 	xgf_unlock(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  408) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  409) 	return retval;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  410) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  411) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  412) static ssize_t xgf_spid_list_show(struct kobject *kobj,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  413) 	struct kobj_attribute *attr, char *buf)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  414) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  415) 	struct xgf_spid *xgf_spid_iter = NULL;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  416) 	char temp[FPSGO_SYSFS_MAX_BUFF_SIZE] = "";
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  417) 	int pos = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  418) 	int length;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  419) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  420) 	length = scnprintf(temp + pos, FPSGO_SYSFS_MAX_BUFF_SIZE - pos,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  421) 		"%s\t%s\t%s\n",
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  422) 		"process_name",
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  423) 		"thread_name",
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  424) 		"action");
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  425) 	pos += length;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  426) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  427) 	hlist_for_each_entry(xgf_spid_iter, &xgf_spid_list, hlist) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  428) 		length = scnprintf(temp + pos, FPSGO_SYSFS_MAX_BUFF_SIZE - pos,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  429) 			"%s\t%s\t%d\n",
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  430) 			xgf_spid_iter->process_name,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  431) 			xgf_spid_iter->thread_name,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  432) 			xgf_spid_iter->action);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  433) 		pos += length;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  434) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  435) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  436) 	length = scnprintf(temp + pos, FPSGO_SYSFS_MAX_BUFF_SIZE - pos,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  437) 		"\n%s\t%s\t%s\t%s\t%s\t%s\n",
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  438) 		"process_name",
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  439) 		"thread_name",
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  440) 		"render",
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  441) 		"pid",
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  442) 		"tid",
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  443) 		"action");
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  444) 	pos += length;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  445) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  446) 	hlist_for_each_entry(xgf_spid_iter, &xgf_wspid_list, hlist) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  447) 		length = scnprintf(temp + pos, FPSGO_SYSFS_MAX_BUFF_SIZE - pos,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  448) 			"%s\t%s\t%d\t%d\t%d\n",
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  449) 			xgf_spid_iter->process_name,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  450) 			xgf_spid_iter->thread_name,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  451) 			xgf_spid_iter->rpid,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  452) 			xgf_spid_iter->pid,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  453) 			xgf_spid_iter->tid,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  454) 			xgf_spid_iter->action);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  455) 		pos += length;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  456) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  457) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  458) 	return scnprintf(buf, PAGE_SIZE, "%s", temp);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  459) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  460) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  461) static ssize_t xgf_spid_list_store(struct kobject *kobj,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  462) 	struct kobj_attribute *attr, const char *buf, size_t count)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  463) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  464) 	char acBuffer[FPSGO_SYSFS_MAX_BUFF_SIZE];
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  465) 	int ret = count;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  466) 	char proc_name[16], thrd_name[16];
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  467) 	int action;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  468) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  469) 	if ((count > 0) && (count < FPSGO_SYSFS_MAX_BUFF_SIZE)) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  470) 		if (scnprintf(acBuffer, FPSGO_SYSFS_MAX_BUFF_SIZE, "%s", buf)) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  471) 			acBuffer[count] = '\0';
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  472) 			if (sscanf(acBuffer, "%15s %15s %d",
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  473) 				proc_name, thrd_name, &action) != 3)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  474) 				goto err;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  475) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  476) 			if (set_xgf_spid_list(proc_name, thrd_name, action))
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  477) 				goto err;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  478) 		}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  479) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  480) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  481) err:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  482) 	return ret;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  483) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  484) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  485) static KOBJ_ATTR_RW(xgf_spid_list);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  486) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  487) static void xgf_reset_wspid_list(void)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  488) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  489) 	struct xgf_spid *xgf_spid_iter;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  490) 	struct hlist_node *t;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  491) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  492) 	xgf_lockprove(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  493) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  494) 	hlist_for_each_entry_safe(xgf_spid_iter, t, &xgf_wspid_list, hlist) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  495) 		hlist_del(&xgf_spid_iter->hlist);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  496) 		xgf_free(xgf_spid_iter);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  497) 		xgf_wspid_list_length--;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  498) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  499) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  500) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  501) static void xgf_render_reset_wspid_list(struct xgf_render *render)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  502) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  503) 	struct xgf_spid *xgf_spid_iter;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  504) 	struct hlist_node *t;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  505) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  506) 	hlist_for_each_entry_safe(xgf_spid_iter, t, &xgf_wspid_list, hlist) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  507) 		if (xgf_spid_iter->rpid == render->render
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  508) 			&& xgf_spid_iter->bufID == render->bufID) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  509) 			hlist_del(&xgf_spid_iter->hlist);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  510) 			xgf_free(xgf_spid_iter);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  511) 			xgf_wspid_list_length--;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  512) 		}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  513) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  514) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  515) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  516) static int xgf_render_setup_wspid_list(struct xgf_render *render)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  517) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  518) 	int ret = 1;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  519) 	struct xgf_spid *xgf_spid_iter;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  520) 	struct task_struct *gtsk, *sib;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  521) 	struct xgf_spid *new_xgf_spid;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  522) 	int tlen = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  523) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  524) 	rcu_read_lock();
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  525) 	gtsk = find_task_by_vpid(render->parent);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  526) 	if (gtsk) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  527) 		get_task_struct(gtsk);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  528) 		list_for_each_entry(sib, &gtsk->thread_group, thread_group) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  529) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  530) 			get_task_struct(sib);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  531) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  532) 			hlist_for_each_entry(xgf_spid_iter, &xgf_spid_list, hlist) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  533) 				if (strncmp(gtsk->comm, xgf_spid_iter->process_name, 16))
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  534) 					continue;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  535) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  536) 				tlen = strlen(xgf_spid_iter->thread_name);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  537) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  538) 				if (!strncmp(sib->comm, xgf_spid_iter->thread_name, tlen)) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  539) 					new_xgf_spid = xgf_alloc(sizeof(*new_xgf_spid));
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  540) 					if (!new_xgf_spid) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  541) 						ret = -ENOMEM;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  542) 						put_task_struct(sib);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  543) 						goto out;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  544) 					}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  545) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  546) 					if (!strncpy(new_xgf_spid->process_name,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  547) 							xgf_spid_iter->process_name, 16)) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  548) 						xgf_free(new_xgf_spid);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  549) 						ret = -ENOMEM;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  550) 						put_task_struct(sib);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  551) 						goto out;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  552) 					}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  553) 					new_xgf_spid->process_name[15] = '\0';
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  554) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  555) 					if (!strncpy(new_xgf_spid->thread_name,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  556) 							xgf_spid_iter->thread_name, 16)) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  557) 						xgf_free(new_xgf_spid);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  558) 						ret = -ENOMEM;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  559) 						put_task_struct(sib);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  560) 						goto out;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  561) 					}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  562) 					new_xgf_spid->thread_name[15] = '\0';
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  563) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  564) 					new_xgf_spid->pid = gtsk->pid;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  565) 					new_xgf_spid->rpid = render->render;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  566) 					new_xgf_spid->tid = sib->pid;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  567) 					new_xgf_spid->bufID = render->bufID;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  568) 					new_xgf_spid->action = xgf_spid_iter->action;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  569) 					hlist_add_head(&new_xgf_spid->hlist, &xgf_wspid_list);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  570) 					xgf_wspid_list_length++;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  571) 				}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  572) 			}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  573) 			put_task_struct(sib);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  574) 		}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  575) out:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  576) 		put_task_struct(gtsk);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  577) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  578) 	rcu_read_unlock();
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  579) 	return ret;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  580) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  581) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  582) static inline int xgf_ull_multi_add_overflow
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  583) 	(int cmd, unsigned long long a, unsigned long long b)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  584) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  585) 	int ret = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  586) 	unsigned long long result_after_sub, div_after_multi;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  587) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  588) 	if (!a || !b)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  589) 		goto out;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  590) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  591) 	if (cmd) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  592) 		/* check add */
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  593) 		result_after_sub = ((a+b)-b);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  594) 		if (a != result_after_sub)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  595) 			ret = 1;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  596) 	} else {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  597) 		/* check multi */
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  598) 		div_after_multi = div_s64((a*b), b);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  599) 		if (a != div_after_multi)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  600) 			ret = 1;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  601) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  602) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  603) out:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  604) 	return ret;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  605) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  606) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  607) static void xgf_reset_render_sector(struct xgf_render *render)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  608) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  609) 	struct hlist_node *s, *p;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  610) 	struct xgf_render_sector *sect_iter;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  611) 	struct xgf_pid_rec *pids_iter;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  612) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  613) 	xgf_lockprove(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  614) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  615) 	hlist_for_each_entry_safe(sect_iter, s, &render->sector_head, hlist) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  616) 		hlist_for_each_entry_safe(pids_iter, p,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  617) 				&sect_iter->path_head, hlist) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  618) 			hlist_del(&pids_iter->hlist);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  619) 			xgf_free(pids_iter);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  620) 		}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  621) 		INIT_HLIST_HEAD(&sect_iter->path_head);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  622) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  623) 		hlist_del(&sect_iter->hlist);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  624) 		xgf_free(sect_iter);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  625) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  626) 	INIT_HLIST_HEAD(&render->sector_head);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  627) 	render->sector_nr = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  628) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  629) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  630) static void xgf_reset_render_hw_list(struct xgf_render *render)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  631) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  632) 	struct hlist_node *h;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  633) 	struct xgf_hw_rec *hw_iter;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  634) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  635) 	xgf_lockprove(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  636) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  637) 	hlist_for_each_entry_safe(hw_iter, h, &render->hw_head, hlist) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  638) 		hlist_del(&hw_iter->hlist);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  639) 		xgf_free(hw_iter);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  640) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  641) 	INIT_HLIST_HEAD(&render->hw_head);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  642) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  643) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  644) static void xgf_clean_hw_events(void)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  645) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  646) 	struct xgf_hw_event *iter;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  647) 	struct hlist_node *t;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  648) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  649) 	xgf_lockprove(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  650) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  651) 	hlist_for_each_entry_safe(iter, t, &xgf_hw_events, hlist) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  652) 		hlist_del(&iter->hlist);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  653) 		xgf_free(iter);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  654) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  655) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  656) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  657) void xgf_clean_deps_list(struct xgf_render *render, int pos)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  658) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  659) 	struct xgf_dep *iter;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  660) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  661) 	xgf_lockprove(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  662) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  663) 	if (pos == INNER_DEPS) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  664) 		while (!RB_EMPTY_ROOT(&render->deps_list)) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  665) 			iter = rb_entry(render->deps_list.rb_node,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  666) 						struct xgf_dep, rb_node);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  667) 			rb_erase(&iter->rb_node, &render->deps_list);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  668) 			xgf_free(iter);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  669) 		}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  670) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  671) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  672) 	if (pos == OUTER_DEPS) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  673) 		while (!RB_EMPTY_ROOT(&render->out_deps_list)) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  674) 			iter = rb_entry(render->out_deps_list.rb_node,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  675) 						struct xgf_dep, rb_node);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  676) 			rb_erase(&iter->rb_node, &render->out_deps_list);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  677) 			xgf_free(iter);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  678) 		}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  679) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  680) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  681) 	if (pos == PREVI_DEPS) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  682) 		while (!RB_EMPTY_ROOT(&render->prev_deps_list)) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  683) 			iter = rb_entry(render->prev_deps_list.rb_node,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  684) 						struct xgf_dep, rb_node);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  685) 			rb_erase(&iter->rb_node, &render->prev_deps_list);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  686) 			xgf_free(iter);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  687) 		}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  688) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  689) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  690) EXPORT_SYMBOL(xgf_clean_deps_list);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  691) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  692) int xgf_dep_frames_mod(struct xgf_render *render, int pos)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  693) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  694) 	int ret = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  695) 	int pre_dep_frames;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  696) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  697) 	xgf_lockprove(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  698) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  699) 	pre_dep_frames = render->dep_frames - 1;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  700) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  701) 	if (pos == PREVI_DEPS) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  702) 		if (render->frame_count == 0)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  703) 			ret = INT_MAX%pre_dep_frames;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  704) 		else
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  705) 			ret = (render->frame_count - 1)%pre_dep_frames;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  706) 	} else
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  707) 		ret = render->frame_count%pre_dep_frames;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  708) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  709) 	return ret;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  710) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  711) EXPORT_SYMBOL(xgf_dep_frames_mod);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  712) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  713) struct xgf_dep *xgf_get_dep(
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  714) 	pid_t tid, struct xgf_render *render, int pos, int force)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  715) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  716) 	struct rb_root *r = NULL;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  717) 	struct rb_node **p = NULL;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  718) 	struct rb_node *parent = NULL;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  719) 	struct xgf_dep *xd = NULL;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  720) 	pid_t tp;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  721) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  722) 	xgf_lockprove(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  723) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  724) 	switch (pos) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  725) 	case INNER_DEPS:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  726) 		p = &render->deps_list.rb_node;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  727) 		r = &render->deps_list;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  728) 		break;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  729) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  730) 	case OUTER_DEPS:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  731) 		p = &render->out_deps_list.rb_node;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  732) 		r = &render->out_deps_list;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  733) 		break;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  734) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  735) 	case PREVI_DEPS:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  736) 		p = &render->prev_deps_list.rb_node;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  737) 		r = &render->prev_deps_list;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  738) 		break;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  739) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  740) 	default:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  741) 		return NULL;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  742) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  743) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  744) 	while (*p) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  745) 		parent = *p;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  746) 		xd = rb_entry(parent, struct xgf_dep, rb_node);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  747) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  748) 		tp = xd->tid;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  749) 		if (tid < tp)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  750) 			p = &(*p)->rb_left;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  751) 		else if (tid > tp)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  752) 			p = &(*p)->rb_right;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  753) 		else
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  754) 			return xd;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  755) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  756) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  757) 	if (!force)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  758) 		return NULL;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  759) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  760) 	xd = xgf_alloc(sizeof(*xd));
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  761) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  762) 	if (!xd)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  763) 		return NULL;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  764) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  765) 	xd->tid = tid;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  766) 	xd->render_dep = 1;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  767) 	xd->frame_idx = xgf_dep_frames_mod(render, pos);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  768) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  769) 	rb_link_node(&xd->rb_node, parent, p);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  770) 	rb_insert_color(&xd->rb_node, r);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  771) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  772) 	return xd;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  773) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  774) EXPORT_SYMBOL(xgf_get_dep);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  775) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  776) static struct xgf_hw_rec *xgf_get_hw_rec(int event_type,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  777) 	unsigned long long mid, struct xgf_render *render, int force)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  778) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  779) 	struct xgf_hw_rec *iter;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  780) 	struct xgf_hw_rec *xhr = NULL;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  781) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  782) 	xgf_lockprove(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  783) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  784) 	hlist_for_each_entry(iter, &render->hw_head, hlist) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  785) 		if (iter->event_type != event_type)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  786) 			continue;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  787) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  788) 		if (iter->mid != mid)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  789) 			continue;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  790) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  791) 		if (iter)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  792) 			xhr = iter;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  793) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  794) 		return xhr;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  795) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  796) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  797) 	if (!force)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  798) 		return NULL;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  799) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  800) 	xhr = xgf_alloc(sizeof(*xhr));
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  801) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  802) 	if (!xhr)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  803) 		return NULL;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  804) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  805) 	xhr->event_type = event_type;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  806) 	xhr->hw_type = PER_FRAME;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  807) 	xhr->mid = mid;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  808) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  809) 	hlist_add_head(&xhr->hlist, &render->hw_head);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  810) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  811) 	return xhr;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  812) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  813) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  814) static void xgf_hw_event_update(unsigned long long max_ts,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  815) 	unsigned long long min_ts, int rpid, struct xgf_render *render)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  816) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  817) 	struct xgf_hw_event *iter;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  818) 	struct hlist_node *t;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  819) 	struct xgf_dep *xd;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  820) 	struct xgf_hw_rec *xhr;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  821) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  822) 	xgf_lockprove(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  823) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  824) 	hlist_for_each_entry_safe(iter, t, &xgf_hw_events, hlist) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  825) 		if (!iter->tail_ts || iter->tail_ts > max_ts
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  826) 				|| iter->tail_ts < min_ts)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  827) 			continue;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  828) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  829) 		xd = xgf_get_dep(iter->tid, render, INNER_DEPS, 0);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  830) 		if (!xd)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  831) 			continue;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  832) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  833) 		iter->render = rpid;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  834) 		iter->valid = 1;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  835) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  836) 		iter->event_index = render->frame_count;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  837) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  838) 		xhr = xgf_get_hw_rec(iter->event_type, iter->mid, render, 1);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  839) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  840) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  841) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  842) static int xgf_valid_hw_index(int check_index, int current_index)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  843) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  844) 	int ret = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  845) 	int lower_bound = current_index - HW_MONITER_WINDOW + 1;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  846) 	int invert_bound;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  847) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  848) 	if (check_index < 0 || current_index < 0)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  849) 		return ret;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  850) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  851) 	if (unlikely(lower_bound < 0)) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  852) 		if (check_index >= 0 && check_index <= current_index)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  853) 			ret = 1;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  854) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  855) 		invert_bound = INT_MAX + lower_bound;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  856) 		if (check_index > invert_bound)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  857) 			ret = 1;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  858) 	} else {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  859) 		if (check_index <= current_index && check_index >= lower_bound)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  860) 			ret = 1;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  861) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  862) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  863) 	return ret;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  864) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  865) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  866) static int xgf_is_valid_hw_event(int rpid, int event_type,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  867) 				int index, struct xgf_hw_event *event)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  868) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  869) 	if (event->event_index == -1 || event->event_type != event_type)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  870) 		return 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  871) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  872) 	if (event->render != rpid || !event->valid)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  873) 		return 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  874) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  875) 	if (!xgf_valid_hw_index(event->event_index, index))
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  876) 		return 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  877) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  878) 	return 1;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  879) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  880) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  881) static int xgf_hw_index_distance(int input_index, int current_index)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  882) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  883) 	int ret = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  884) 	int lower_bound = current_index - HW_MONITER_WINDOW + 1;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  885) 	int invert_bound;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  886) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  887) 	if (input_index < 0 || current_index < 0)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  888) 		return ret;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  889) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  890) 	if (unlikely(lower_bound < 0)) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  891) 		invert_bound = INT_MAX + lower_bound;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  892) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  893) 		if (input_index <= current_index)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  894) 			ret = current_index - input_index + 1;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  895) 		else if (input_index >= invert_bound)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  896) 			ret = (INT_MAX - input_index + 1) + (current_index + 1);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  897) 	} else
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  898) 		ret = current_index - input_index + 1;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  899) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  900) 	return ret;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  901) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  902) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  903) static int xgf_hw_type(int rpid, struct xgf_render *render)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  904) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  905) 	int event, curr_index, stored_count, valid_count, t_count;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  906) 	int level;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  907) 	struct xgf_hw_rec *hr_iter;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  908) 	struct hlist_node *hr;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  909) 	struct xgf_hw_event *he_iter;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  910) 	struct hlist_node *he;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  911) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  912) 	xgf_lockprove(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  913) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  914) 	for (event = 0; event < HW_EVENT_NUM; event++) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  915) 		curr_index = render->frame_count;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  916) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  917) 		hlist_for_each_entry_safe(hr_iter, hr,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  918) 						&render->hw_head, hlist) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  919) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  920) 			if (hr_iter->event_type != event)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  921) 				continue;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  922) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  923) 			valid_count = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  924) 			stored_count = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  925) 			level = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  926) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  927) 			hlist_for_each_entry_safe(he_iter, he,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  928) 							&xgf_hw_events, hlist) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  929) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  930) 				if (hr_iter->mid != he_iter->mid)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  931) 					continue;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  932) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  933) 				if (!xgf_is_valid_hw_event(rpid,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  934) 						event, curr_index, he_iter))
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  935) 					continue;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  936) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  937) 				t_count = xgf_hw_index_distance(
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  938) 					he_iter->event_index, curr_index);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  939) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  940) 				if (t_count > stored_count)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  941) 					stored_count = t_count;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  942) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  943) 				valid_count++;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  944) 			}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  945) 			xgf_trace("xgf hw type valid_count:%d stored_count:%d",
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  946) 						valid_count, stored_count);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  947) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  948) 			if (valid_count > 0 && stored_count > 0) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  949) 				level = (valid_count*10)/stored_count;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  950) 				if (level >= HW_MONITER_LEVEL)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  951) 					hr_iter->hw_type = PER_FRAME;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  952) 				else
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  953) 					hr_iter->hw_type = CRO_FRAME;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  954) 			} else {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  955) 				if (stored_count > 0)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  956) 					hr_iter->hw_type = BACKGROUND;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  957) 				else {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  958) 					hlist_del(&hr_iter->hlist);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  959) 					xgf_free(hr_iter);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  960) 				}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  961) 			}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  962) 		}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  963) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  964) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  965) 	return 1;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  966) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  967) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  968) int xgf_hw_events_update(int rpid, struct xgf_render *render)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  969) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  970) 	int ret = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  971) 	unsigned long long min_ts, max_ts;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  972) 	struct xgf_hw_event *iter;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  973) 	struct hlist_node *t, *p, *s;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  974) 	struct xgf_pid_rec *pids_iter;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  975) 	struct xgf_render_sector *xrs;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  976) 	struct xgf_hw_rec *xhr;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  977) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  978) 	xgf_lockprove(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  979) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  980) 	max_ts = render->curr_ts;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  981) 	min_ts = render->prev_ts;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  982) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  983) 	xgf_hw_event_update(max_ts, min_ts, rpid, render);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  984) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  985) 	ret = xgf_hw_type(rpid, render);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  986) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  987) 	/* ignore run time calculate when cross frame */
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  988) 	hlist_for_each_entry_safe(iter, t, &xgf_hw_events, hlist) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  989) 		if (!iter->tail_ts || !iter->valid
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  990) 			|| iter->tail_ts > max_ts || iter->tail_ts < min_ts)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  991) 			continue;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  992) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  993) 		hlist_for_each_entry_safe(xrs, s, &render->sector_head, hlist) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  994) 			if (iter->tail_ts > xrs->tail_ts
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  995) 				|| iter->tail_ts < xrs->head_ts)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  996) 				continue;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  997) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  998) 			hlist_for_each_entry_safe(pids_iter, p,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000  999) 				&xrs->path_head, hlist) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1000) 				if (pids_iter->pid == iter->tid) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1001) 					xhr = xgf_get_hw_rec(iter->event_type,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1002) 					iter->mid, render, 0);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1003) 					if (!xhr)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1004) 						continue;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1005) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1006) 					if (xhr->hw_type == CRO_FRAME)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1007) 						xrs->counted = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1008) 				}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1009) 			}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1010) 		}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1011) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1012) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1013) 	return ret;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1014) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1015) EXPORT_SYMBOL(xgf_hw_events_update);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1016) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1017) static void xgf_hw_event_begin(int event_type, int tid,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1018) 				unsigned long long mid)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1019) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1020) 	struct xgf_hw_event *event;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1021) 	unsigned long long now_ts = xgf_get_time();
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1022) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1023) 	xgf_lockprove(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1024) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1025) 	event = xgf_alloc(sizeof(*event));
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1026) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1027) 	if (event == NULL)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1028) 		return;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1029) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1030) 	event->event_index = -1;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1031) 	event->render = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1032) 	event->valid = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1033) 	event->event_type = event_type;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1034) 	event->head_ts = now_ts;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1035) 	event->tid = tid;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1036) 	event->mid = mid;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1037) 	event->tail_ts = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1038) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1039) 	hlist_add_head(&event->hlist, &xgf_hw_events);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1040) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1041) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1042) static int xgf_hw_event_end(int event_type, int tid,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1043) 				unsigned long long mid)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1044) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1045) 	struct xgf_hw_event *event;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1046) 	struct xgf_hw_rec *xhr;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1047) 	struct xgf_render *r_iter;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1048) 	struct hlist_node *tmp, *r_tmp;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1049) 	unsigned long long now_ts = xgf_get_time();
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1050) 	int ret = PER_FRAME;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1051) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1052) 	xgf_lockprove(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1053) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1054) 	hlist_for_each_entry_safe(event, tmp, &xgf_hw_events, hlist) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1055) 		if (event->tid != tid || event->tail_ts)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1056) 			continue;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1057) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1058) 		event->tail_ts = now_ts;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1059) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1060) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1061) 	hlist_for_each_entry_safe(r_iter, r_tmp, &xgf_renders, hlist) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1062) 		xhr = xgf_get_hw_rec(event_type, mid, r_iter, 0);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1063) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1064) 		if (xhr) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1065) 			ret = xhr->hw_type;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1066) 			break;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1067) 		}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1068) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1069) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1070) 	return ret;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1071) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1072) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1073) static int xgf_hw_event_collect(int event_type, int tid,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1074) 				unsigned long long mid, int cmd)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1075) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1076) 	int ret = PER_FRAME;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1077) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1078) 	xgf_lock(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1079) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1080) 	if (!xgf_is_enable()) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1081) 		xgf_unlock(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1082) 		return ret;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1083) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1084) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1085) 	switch (cmd) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1086) 	case 1:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1087) 		xgf_hw_event_begin(event_type, tid, mid);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1088) 		break;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1089) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1090) 	case 0:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1091) 	default:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1092) 		ret = xgf_hw_event_end(event_type, tid, mid);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1093) 		break;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1094) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1095) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1096) 	xgf_unlock(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1097) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1098) 	return ret;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1099) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1100) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1101) static int xgf_get_render(pid_t rpid, unsigned long long bufID,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1102) 	struct xgf_render **ret, int force)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1103) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1104) 	struct xgf_render *iter;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1105) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1106) 	xgf_lockprove(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1107) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1108) 	hlist_for_each_entry(iter, &xgf_renders, hlist) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1109) 		if (iter->render != rpid)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1110) 			continue;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1111) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1112) 		if (iter->bufID != bufID)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1113) 			continue;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1114) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1115) 		if (ret)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1116) 			*ret = iter;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1117) 		return 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1118) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1119) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1120) 	if (!force)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1121) 		return -EINVAL;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1122) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1123) 	iter = xgf_alloc(sizeof(*iter));
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1124) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1125) 	if (!iter)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1126) 		return -ENOMEM;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1127) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1128) 	{
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1129) 		struct task_struct *tsk;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1130) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1131) 		rcu_read_lock();
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1132) 		tsk = find_task_by_vpid(rpid);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1133) 		if (tsk)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1134) 			get_task_struct(tsk);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1135) 		rcu_read_unlock();
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1136) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1137) 		if (!tsk) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1138) 			xgf_free(iter);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1139) 			return -EINVAL;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1140) 		}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1141) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1142) 		iter->parent = tsk->tgid;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1143) 		iter->render = rpid;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1144) 		put_task_struct(tsk);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1145) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1146) 		iter->bufID = bufID;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1147) 		iter->sector_nr = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1148) 		iter->curr_index = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1149) 		iter->curr_ts = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1150) 		iter->prev_index = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1151) 		iter->prev_ts = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1152) 		iter->event_count = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1153) 		iter->frame_count = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1154) 		iter->u_wake_r = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1155) 		iter->u_wake_r_count = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1156) 		iter->queue.start_ts = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1157) 		iter->queue.end_ts = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1158) 		iter->deque.start_ts = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1159) 		iter->deque.end_ts = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1160) 		iter->ema_runtime = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1161) 		iter->pre_u_runtime = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1162) 		iter->u_avg_runtime = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1163) 		iter->u_runtime_sd = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1164) 		iter->u_runtime_idx = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1165) 		iter->spid = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1166) 		iter->dep_frames = xgf_prev_dep_frames;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1167) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1168) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1169) 	INIT_HLIST_HEAD(&iter->sector_head);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1170) 	INIT_HLIST_HEAD(&iter->hw_head);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1171) 	hlist_add_head(&iter->hlist, &xgf_renders);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1172) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1173) 	if (ret)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1174) 		*ret = iter;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1175) 	return 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1176) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1177) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1178) static inline int xgf_ull_multi_overflow(
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1179) 	unsigned long long multiplicand, int multiplier)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1180) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1181) 	int ret = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1182) 	unsigned long long div_after_multi;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1183) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1184) 	div_after_multi = div_u64((multiplicand*multiplier), multiplier);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1185) 	if (multiplicand != div_after_multi)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1186) 		ret = 1;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1187) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1188) 	return ret;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1189) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1190) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1191) static inline unsigned long long xgf_runtime_pro_rata(
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1192) 	unsigned long long val, int dividend, int divisor)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1193) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1194) 	unsigned long long ret = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1195) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1196) 	if (xgf_ull_multi_overflow(val, dividend))
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1197) 		ret = div_u64(ULLONG_MAX, divisor);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1198) 	else
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1199) 		ret = div_u64((val*dividend), divisor);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1200) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1201) 	return ret;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1202) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1203) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1204) static inline unsigned long long xgf_ema_cal(
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1205) 	unsigned long long curr, unsigned long long prev)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1206) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1207) 	unsigned long long ret = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1208) 	unsigned long long curr_new, prev_new;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1209) 	int xgf_ema_rest_dividend;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1210) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1211) 	if (!prev) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1212) 		ret = curr;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1213) 		return ret;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1214) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1215) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1216) 	if (xgf_ema_dividend > 9 || xgf_ema_dividend < 1)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1217) 		xgf_ema_dividend = EMA_DIVIDEND;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1218) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1219) 	xgf_ema_rest_dividend = EMA_DIVISOR - xgf_ema_dividend;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1220) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1221) 	curr_new = xgf_runtime_pro_rata(curr, xgf_ema_dividend, EMA_DIVISOR);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1222) 	prev_new =
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1223) 		xgf_runtime_pro_rata(prev, xgf_ema_rest_dividend, EMA_DIVISOR);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1224) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1225) 	if (prev_new > (ULLONG_MAX - curr_new))
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1226) 		ret = ULLONG_MAX; /* overflow */
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1227) 	else
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1228) 		ret = curr_new + prev_new;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1229) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1230) 	return ret;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1231) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1232) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1233) void fpsgo_create_render_dep(void) {}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1234) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1235) void fpsgo_update_render_dep(struct task_struct *p) {}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1236) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1237) void xgf_igather_timer(const void * const timer, int fire) {}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1238) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1239) void xgf_epoll_igather_timer(
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1240) 	const void * const timer, ktime_t *expires, int fire)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1241) {}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1242) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1243) int xgf_uboost_case(struct xgf_render *render)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1244) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1245) 	int quarter, ret = 0, shift = 2;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1246) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1247) 	quarter = render->frame_count >> shift;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1248) 	if (quarter < render->u_wake_r_count)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1249) 		ret = 1;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1250) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1251) 	return ret;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1252) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1253) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1254) static void xgf_add_pid2prev_dep(struct xgf_render *render, int tid)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1255) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1256) 	struct xgf_dep *xd;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1257) 	int curr_frame_index;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1258) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1259) 	if (!tid || !render || tid < 0)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1260) 		return;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1261) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1262) 	curr_frame_index = xgf_dep_frames_mod(render, PREVI_DEPS);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1263) 	xd = xgf_get_dep(tid, render, PREVI_DEPS, 0);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1264) 	if (xd)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1265) 		xd->frame_idx = curr_frame_index;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1266) 	else
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1267) 		xd = xgf_get_dep(tid, render, PREVI_DEPS, 1);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1268) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1269) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1270) static void xgf_wspid_list_add2prev(struct xgf_render *render)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1271) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1272) 	struct xgf_spid *xgf_spid_iter;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1273) 	struct hlist_node *t;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1274) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1275) 	xgf_lockprove(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1276) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1277) 	hlist_for_each_entry_safe(xgf_spid_iter, t, &xgf_wspid_list, hlist) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1278) 		if (xgf_spid_iter->rpid == render->render
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1279) 			&& xgf_spid_iter->bufID == render->bufID)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1280) 			xgf_add_pid2prev_dep(render, xgf_spid_iter->tid);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1281) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1282) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1283) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1284) int uboost2xgf_get_info(int pid, unsigned long long bufID,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1285) 	unsigned long long *timer_period, int *frame_idx)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1286) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1287) 	int ret = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1288) 	struct xgf_render *render_iter;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1289) 	struct hlist_node *n;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1290) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1291) 	if (!xgf_uboost || !pid)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1292) 		goto out;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1293) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1294) 	xgf_lock(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1295) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1296) 	hlist_for_each_entry_safe(render_iter, n, &xgf_renders, hlist) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1297) 		if (render_iter->render != pid)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1298) 			continue;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1299) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1300) 		if (render_iter->bufID != bufID)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1301) 			continue;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1302) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1303) 		if (!xgf_uboost_case(render_iter))
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1304) 			continue;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1305) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1306) 		*frame_idx = render_iter->frame_count;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1307) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1308) 		fpsgo_systrace_c_xgf(render_iter->render,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1309) 			render_iter->bufID, render_iter->u_avg_runtime, "ub_avg");
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1310) 		fpsgo_systrace_c_xgf(render_iter->render,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1311) 			render_iter->bufID, render_iter->u_runtime_sd, "ub_stddev");
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1312) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1313) 		if ((xgf_ull_multi_add_overflow(
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1314) 			0, render_iter->u_runtime_sd, xgf_stddev_multi))
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1315) 			|| (xgf_ull_multi_add_overflow(
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1316) 			1, render_iter->u_avg_runtime,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1317) 			(xgf_stddev_multi*render_iter->u_runtime_sd)))) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1318) 			*timer_period = 0; /* overflow */
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1319) 		} else {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1320) 			*timer_period =
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1321) 				render_iter->u_avg_runtime +
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1322) 				xgf_stddev_multi*render_iter->u_runtime_sd;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1323) 			ret = 1;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1324) 		}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1325) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1326) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1327) 	xgf_unlock(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1328) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1329) out:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1330) 	return ret;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1331) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1332) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1333) static int xgf_tid_overlap(int tid, int rpid, int uboost)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1334) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1335) 	int ret = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1336) 	struct xgf_render *render_iter;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1337) 	struct hlist_node *n;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1338) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1339) 	if (!tid || tid < 0 || uboost)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1340) 		goto out;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1341) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1342) 	hlist_for_each_entry_safe(render_iter, n, &xgf_renders, hlist) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1343) 		if (render_iter->render == rpid)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1344) 			continue;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1345) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1346) 		if (render_iter->render == tid || render_iter->parent == tid) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1347) 			ret = 1;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1348) 			goto out;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1349) 		}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1350) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1351) out:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1352) 	return ret;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1353) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1354) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1355) int has_xgf_dep(pid_t tid)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1356) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1357) 	struct xgf_dep *out_xd, *prev_xd;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1358) 	struct xgf_render *render_iter;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1359) 	struct hlist_node *n;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1360) 	pid_t query_tid;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1361) 	int ret = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1362) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1363) 	xgf_lock(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1364) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1365) 	query_tid = tid;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1366) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1367) 	hlist_for_each_entry_safe(render_iter, n, &xgf_renders, hlist) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1368) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1369) 		/* prevent minitop release ceil at sp sub condition */
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1370) 		if (xgf_spid_sub && xgf_sp_name_id && query_tid
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1371) 			&& query_tid == render_iter->spid) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1372) 			ret = 1;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1373) 			break;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1374) 		}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1375) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1376) 		out_xd = xgf_get_dep(query_tid, render_iter, OUTER_DEPS, 0);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1377) 		prev_xd = xgf_get_dep(query_tid, render_iter, PREVI_DEPS, 0);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1378) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1379) 		if (!out_xd && !prev_xd)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1380) 			continue;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1381) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1382) 		if ((out_xd && out_xd->render_dep)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1383) 			|| (prev_xd && prev_xd->render_dep))
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1384) 			ret = 1;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1385) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1386) 		if (ret)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1387) 			break;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1388) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1389) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1390) 	xgf_unlock(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1391) 	return ret;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1392) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1393) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1394) int gbe2xgf_get_dep_list_num(int pid, unsigned long long bufID)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1395) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1396) 	struct xgf_render *render_iter;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1397) 	struct hlist_node *n;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1398) 	struct rb_node *out_rbn;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1399) 	struct rb_node *pre_rbn;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1400) 	struct xgf_dep *out_iter;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1401) 	struct xgf_dep *pre_iter;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1402) 	int counts = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1403) 	int xgf_r_uboost = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1404) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1405) 	if (!pid)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1406) 		goto out;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1407) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1408) 	xgf_lock(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1409) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1410) 	hlist_for_each_entry_safe(render_iter, n, &xgf_renders, hlist) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1411) 		xgf_r_uboost = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1412) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1413) 		if (render_iter->render != pid)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1414) 			continue;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1415) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1416) 		if (render_iter->bufID != bufID)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1417) 			continue;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1418) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1419) 		xgf_r_uboost = xgf_uboost_case(render_iter);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1420) 		if (xgf_r_uboost && xgf_uboost)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1421) 			xgf_add_pid2prev_dep(render_iter, render_iter->parent);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1422) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1423) 		if (render_iter->spid)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1424) 			xgf_add_pid2prev_dep(render_iter, render_iter->spid);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1425) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1426) 		if (xgf_cfg_spid)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1427) 			xgf_wspid_list_add2prev(render_iter);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1428) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1429) 		out_rbn = rb_first(&render_iter->out_deps_list);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1430) 		pre_rbn = rb_first(&render_iter->prev_deps_list);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1431) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1432) 		while (out_rbn != NULL && pre_rbn != NULL) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1433) 			out_iter = rb_entry(out_rbn, struct xgf_dep, rb_node);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1434) 			pre_iter = rb_entry(pre_rbn, struct xgf_dep, rb_node);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1435) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1436) 			if (out_iter->tid < pre_iter->tid) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1437) 				if (out_iter->render_dep
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1438) 					&& !xgf_tid_overlap(out_iter->tid, pid, xgf_r_uboost))
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1439) 					counts++;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1440) 				out_rbn = rb_next(out_rbn);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1441) 			} else if (out_iter->tid > pre_iter->tid) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1442) 				if (pre_iter->render_dep
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1443) 					&& !xgf_tid_overlap(pre_iter->tid, pid, xgf_r_uboost))
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1444) 					counts++;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1445) 				pre_rbn = rb_next(pre_rbn);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1446) 			} else {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1447) 				if ((out_iter->render_dep || pre_iter->render_dep)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1448) 					&& !xgf_tid_overlap(out_iter->tid, pid, xgf_r_uboost))
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1449) 					counts++;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1450) 				out_rbn = rb_next(out_rbn);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1451) 				pre_rbn = rb_next(pre_rbn);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1452) 			}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1453) 		}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1454) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1455) 		while (out_rbn != NULL) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1456) 			out_iter = rb_entry(out_rbn, struct xgf_dep, rb_node);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1457) 			if (out_iter->render_dep
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1458) 				&& !xgf_tid_overlap(out_iter->tid, pid, xgf_r_uboost))
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1459) 				counts++;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1460) 			out_rbn = rb_next(out_rbn);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1461) 		}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1462) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1463) 		while (pre_rbn != NULL) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1464) 			pre_iter = rb_entry(pre_rbn, struct xgf_dep, rb_node);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1465) 			if (pre_iter->render_dep
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1466) 				&& !xgf_tid_overlap(pre_iter->tid, pid, xgf_r_uboost))
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1467) 				counts++;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1468) 			pre_rbn = rb_next(pre_rbn);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1469) 		}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1470) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1471) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1472) 	xgf_unlock(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1473) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1474) out:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1475) 	return counts;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1476) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1477) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1478) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1479) int fpsgo_fbt2xgf_get_dep_list_num(int pid, unsigned long long bufID)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1480) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1481) 	struct xgf_render *render_iter;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1482) 	struct hlist_node *n;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1483) 	struct rb_node *out_rbn;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1484) 	struct rb_node *pre_rbn;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1485) 	struct xgf_dep *out_iter;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1486) 	struct xgf_dep *pre_iter;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1487) 	int counts = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1488) 	int xgf_r_uboost = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1489) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1490) 	if (!pid)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1491) 		goto out;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1492) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1493) 	xgf_lock(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1494) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1495) 	hlist_for_each_entry_safe(render_iter, n, &xgf_renders, hlist) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1496) 		xgf_r_uboost = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1497) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1498) 		if (render_iter->render != pid)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1499) 			continue;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1500) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1501) 		if (render_iter->bufID != bufID)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1502) 			continue;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1503) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1504) 		xgf_r_uboost = xgf_uboost_case(render_iter);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1505) 		if (xgf_r_uboost && xgf_uboost)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1506) 			xgf_add_pid2prev_dep(render_iter, render_iter->parent);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1507) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1508) 		if (render_iter->spid)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1509) 			xgf_add_pid2prev_dep(render_iter, render_iter->spid);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1510) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1511) 		if (xgf_cfg_spid)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1512) 			xgf_wspid_list_add2prev(render_iter);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1513) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1514) 		out_rbn = rb_first(&render_iter->out_deps_list);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1515) 		pre_rbn = rb_first(&render_iter->prev_deps_list);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1516) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1517) 		while (out_rbn != NULL && pre_rbn != NULL) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1518) 			out_iter = rb_entry(out_rbn, struct xgf_dep, rb_node);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1519) 			pre_iter = rb_entry(pre_rbn, struct xgf_dep, rb_node);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1520) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1521) 			if (out_iter->tid < pre_iter->tid) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1522) 				if (out_iter->render_dep
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1523) 					&& !xgf_tid_overlap(out_iter->tid, pid, xgf_r_uboost))
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1524) 					counts++;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1525) 				out_rbn = rb_next(out_rbn);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1526) 			} else if (out_iter->tid > pre_iter->tid) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1527) 				if (pre_iter->render_dep
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1528) 					&& !xgf_tid_overlap(pre_iter->tid, pid, xgf_r_uboost))
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1529) 					counts++;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1530) 				pre_rbn = rb_next(pre_rbn);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1531) 			} else {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1532) 				if ((out_iter->render_dep || pre_iter->render_dep)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1533) 					&& !xgf_tid_overlap(out_iter->tid, pid, xgf_r_uboost))
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1534) 					counts++;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1535) 				out_rbn = rb_next(out_rbn);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1536) 				pre_rbn = rb_next(pre_rbn);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1537) 			}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1538) 		}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1539) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1540) 		while (out_rbn != NULL) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1541) 			out_iter = rb_entry(out_rbn, struct xgf_dep, rb_node);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1542) 			if (out_iter->render_dep
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1543) 				&& !xgf_tid_overlap(out_iter->tid, pid, xgf_r_uboost))
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1544) 				counts++;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1545) 			out_rbn = rb_next(out_rbn);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1546) 		}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1547) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1548) 		while (pre_rbn != NULL) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1549) 			pre_iter = rb_entry(pre_rbn, struct xgf_dep, rb_node);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1550) 			if (pre_iter->render_dep
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1551) 				&& !xgf_tid_overlap(pre_iter->tid, pid, xgf_r_uboost))
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1552) 				counts++;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1553) 			pre_rbn = rb_next(pre_rbn);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1554) 		}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1555) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1556) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1557) 	xgf_unlock(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1558) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1559) out:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1560) 	return counts;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1561) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1562) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1563) int gbe2xgf_get_dep_list(int pid, int count,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1564) 	struct gbe_runtime *arr, unsigned long long bufID)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1565) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1566) 	struct xgf_render *render_iter;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1567) 	struct hlist_node *n;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1568) 	struct rb_node *out_rbn;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1569) 	struct rb_node *pre_rbn;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1570) 	struct xgf_dep *out_iter;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1571) 	struct xgf_dep *pre_iter;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1572) 	int index = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1573) 	int xgf_r_uboost = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1574) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1575) 	if (!pid || !count)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1576) 		return 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1577) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1578) 	xgf_lock(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1579) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1580) 	hlist_for_each_entry_safe(render_iter, n, &xgf_renders, hlist) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1581) 		xgf_r_uboost = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1582) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1583) 		if (render_iter->render != pid)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1584) 			continue;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1585) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1586) 		if (render_iter->bufID != bufID)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1587) 			continue;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1588) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1589) 		xgf_r_uboost = xgf_uboost_case(render_iter);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1590) 		if (xgf_r_uboost && xgf_uboost)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1591) 			xgf_add_pid2prev_dep(render_iter, render_iter->parent);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1592) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1593) 		if (render_iter->spid)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1594) 			xgf_add_pid2prev_dep(render_iter, render_iter->spid);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1595) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1596) 		if (xgf_cfg_spid)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1597) 			xgf_wspid_list_add2prev(render_iter);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1598) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1599) 		out_rbn = rb_first(&render_iter->out_deps_list);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1600) 		pre_rbn = rb_first(&render_iter->prev_deps_list);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1601) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1602) 		while (out_rbn != NULL && pre_rbn != NULL) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1603) 			out_iter = rb_entry(out_rbn, struct xgf_dep, rb_node);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1604) 			pre_iter = rb_entry(pre_rbn, struct xgf_dep, rb_node);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1605) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1606) 			if (out_iter->tid < pre_iter->tid) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1607) 				if (out_iter->render_dep && index < count
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1608) 					&& !xgf_tid_overlap(out_iter->tid, pid, xgf_r_uboost)) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1609) 					arr[index].pid = out_iter->tid;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1610) 					index++;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1611) 				}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1612) 				out_rbn = rb_next(out_rbn);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1613) 			} else if (out_iter->tid > pre_iter->tid) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1614) 				if (pre_iter->render_dep && index < count
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1615) 					&& !xgf_tid_overlap(pre_iter->tid, pid, xgf_r_uboost)) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1616) 					arr[index].pid = pre_iter->tid;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1617) 					index++;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1618) 				}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1619) 				pre_rbn = rb_next(pre_rbn);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1620) 			} else {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1621) 				if ((out_iter->render_dep || pre_iter->render_dep)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1622) 					&& !xgf_tid_overlap(out_iter->tid, pid, xgf_r_uboost)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1623) 					&& index < count) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1624) 					arr[index].pid = out_iter->tid;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1625) 					index++;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1626) 				}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1627) 				out_rbn = rb_next(out_rbn);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1628) 				pre_rbn = rb_next(pre_rbn);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1629) 			}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1630) 		}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1631) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1632) 		while (out_rbn != NULL) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1633) 			out_iter = rb_entry(out_rbn, struct xgf_dep, rb_node);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1634) 			if (out_iter->render_dep && index < count
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1635) 				&& !xgf_tid_overlap(out_iter->tid, pid, xgf_r_uboost)) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1636) 				arr[index].pid = out_iter->tid;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1637) 				index++;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1638) 			}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1639) 			out_rbn = rb_next(out_rbn);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1640) 		}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1641) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1642) 		while (pre_rbn != NULL) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1643) 			pre_iter = rb_entry(pre_rbn, struct xgf_dep, rb_node);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1644) 			if (pre_iter->render_dep && index < count
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1645) 				&& !xgf_tid_overlap(pre_iter->tid, pid, xgf_r_uboost)) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1646) 				arr[index].pid = pre_iter->tid;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1647) 				index++;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1648) 			}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1649) 			pre_rbn = rb_next(pre_rbn);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1650) 		}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1651) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1652) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1653) 	xgf_unlock(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1654) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1655) 	return index;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1656) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1657) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1658) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1659) int fpsgo_fbt2xgf_get_dep_list(int pid, int count,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1660) 	struct fpsgo_loading *arr, unsigned long long bufID)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1661) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1662) 	struct xgf_render *render_iter;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1663) 	struct hlist_node *n;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1664) 	struct rb_node *out_rbn;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1665) 	struct rb_node *pre_rbn;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1666) 	struct xgf_dep *out_iter;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1667) 	struct xgf_dep *pre_iter;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1668) 	int index = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1669) 	int xgf_r_uboost = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1670) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1671) 	if (!pid || !count)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1672) 		return 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1673) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1674) 	xgf_lock(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1675) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1676) 	hlist_for_each_entry_safe(render_iter, n, &xgf_renders, hlist) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1677) 		xgf_r_uboost = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1678) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1679) 		if (render_iter->render != pid)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1680) 			continue;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1681) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1682) 		if (render_iter->bufID != bufID)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1683) 			continue;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1684) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1685) 		xgf_r_uboost = xgf_uboost_case(render_iter);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1686) 		if (xgf_r_uboost && xgf_uboost)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1687) 			xgf_add_pid2prev_dep(render_iter, render_iter->parent);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1688) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1689) 		if (render_iter->spid)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1690) 			xgf_add_pid2prev_dep(render_iter, render_iter->spid);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1691) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1692) 		if (xgf_cfg_spid)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1693) 			xgf_wspid_list_add2prev(render_iter);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1694) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1695) 		out_rbn = rb_first(&render_iter->out_deps_list);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1696) 		pre_rbn = rb_first(&render_iter->prev_deps_list);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1697) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1698) 		while (out_rbn != NULL && pre_rbn != NULL) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1699) 			out_iter = rb_entry(out_rbn, struct xgf_dep, rb_node);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1700) 			pre_iter = rb_entry(pre_rbn, struct xgf_dep, rb_node);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1701) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1702) 			if (out_iter->tid < pre_iter->tid) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1703) 				if (out_iter->render_dep && index < count
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1704) 					&& !xgf_tid_overlap(out_iter->tid, pid, xgf_r_uboost)) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1705) 					arr[index].pid = out_iter->tid;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1706) 					index++;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1707) 				}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1708) 				out_rbn = rb_next(out_rbn);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1709) 			} else if (out_iter->tid > pre_iter->tid) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1710) 				if (pre_iter->render_dep && index < count
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1711) 					&& !xgf_tid_overlap(pre_iter->tid, pid, xgf_r_uboost)) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1712) 					arr[index].pid = pre_iter->tid;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1713) 					index++;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1714) 				}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1715) 				pre_rbn = rb_next(pre_rbn);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1716) 			} else {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1717) 				if ((out_iter->render_dep || pre_iter->render_dep)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1718) 					&& !xgf_tid_overlap(out_iter->tid, pid, xgf_r_uboost)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1719) 					&& index < count) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1720) 					arr[index].pid = out_iter->tid;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1721) 					index++;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1722) 				}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1723) 				out_rbn = rb_next(out_rbn);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1724) 				pre_rbn = rb_next(pre_rbn);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1725) 			}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1726) 		}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1727) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1728) 		while (out_rbn != NULL) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1729) 			out_iter = rb_entry(out_rbn, struct xgf_dep, rb_node);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1730) 			if (out_iter->render_dep && index < count
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1731) 				&& !xgf_tid_overlap(out_iter->tid, pid, xgf_r_uboost)) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1732) 				arr[index].pid = out_iter->tid;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1733) 				index++;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1734) 			}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1735) 			out_rbn = rb_next(out_rbn);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1736) 		}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1737) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1738) 		while (pre_rbn != NULL) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1739) 			pre_iter = rb_entry(pre_rbn, struct xgf_dep, rb_node);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1740) 			if (pre_iter->render_dep && index < count
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1741) 				&& !xgf_tid_overlap(pre_iter->tid, pid, xgf_r_uboost)) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1742) 				arr[index].pid = pre_iter->tid;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1743) 				index++;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1744) 			}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1745) 			pre_rbn = rb_next(pre_rbn);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1746) 		}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1747) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1748) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1749) 	xgf_unlock(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1750) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1751) 	return index;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1752) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1753) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1754) void xgf_reset_renders(void)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1755) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1756) 	struct xgf_render *r_iter;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1757) 	struct hlist_node *r_tmp;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1758) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1759) 	xgf_lockprove(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1760) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1761) 	hlist_for_each_entry_safe(r_iter, r_tmp, &xgf_renders, hlist) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1762) 		xgf_clean_deps_list(r_iter, INNER_DEPS);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1763) 		xgf_clean_deps_list(r_iter, OUTER_DEPS);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1764) 		xgf_clean_deps_list(r_iter, PREVI_DEPS);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1765) 		xgf_reset_render_sector(r_iter);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1766) 		xgf_reset_render_hw_list(r_iter);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1767) 		hlist_del(&r_iter->hlist);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1768) 		xgf_free(r_iter);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1769) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1770) 	xgf_reset_wspid_list();
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1771) 	xgf_clean_hw_events();
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1772) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1773) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1774) void fpsgo_ctrl2xgf_nn_job_begin(unsigned int tid, unsigned long long mid)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1775) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1776) 	xgf_hw_event_collect(HW_AI, tid, mid, 1);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1777) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1778) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1779) int fpsgo_ctrl2xgf_nn_job_end(unsigned int tid, unsigned long long mid)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1780) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1781) 	int hw_type = PER_FRAME;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1782) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1783) 	hw_type = xgf_hw_event_collect(HW_AI, tid, mid, 0);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1784) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1785) 	return hw_type;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1786) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1787) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1788) static void xgf_enter_state_xchg(int enable)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1789) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1790) 	int ret = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1791) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1792) 	if (enable != 0 && enable != 1) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1793) 		ret = -1;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1794) 		goto out;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1795) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1796) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1797) 	WARN_ON(!xgf_stat_xchg_fp);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1798) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1799) 	if (xgf_stat_xchg_fp)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1800) 		ret = xgf_stat_xchg_fp(enable);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1801) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1802) out:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1803) 	xgf_trace("xgf k2ko xchg ret:%d enable:%d", ret, enable);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1804) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1805) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1806) void notify_xgf_ko_ready(void)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1807) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1808) 	xgf_lock(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1809) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1810) 	xgf_ko_ready = 1;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1811) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1812) 	if (xgf_is_enable())
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1813) 		xgf_enter_state_xchg(xgf_enable);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1814) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1815) 	xgf_unlock(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1816) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1817) EXPORT_SYMBOL(notify_xgf_ko_ready);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1818) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1819) void fpsgo_ctrl2xgf_switch_xgf(int val)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1820) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1821) 	xgf_lock(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1822) 	if (val != xgf_enable) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1823) 		xgf_enable = val;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1824) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1825) 		xgf_reset_renders();
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1826) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1827) 		if (xgf_ko_is_ready())
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1828) 			xgf_enter_state_xchg(xgf_enable);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1829) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1830) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1831) 	xgf_unlock(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1832) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1833) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1834) void fpsgo_fstb2xgf_do_recycle(int fstb_active)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1835) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1836) 	unsigned long long now_ts = xgf_get_time();
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1837) 	long long diff, check_period, recycle_period;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1838) 	struct xgf_hw_event *hw_iter;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1839) 	struct hlist_node *hw_t;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1840) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1841) 	/* over 1 seconds since last check2recycle */
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1842) 	check_period = NSEC_PER_SEC;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1843) 	recycle_period = NSEC_PER_SEC >> 1;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1844) 	diff = (long long)now_ts - (long long)last_check2recycle_ts;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1845) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1846) 	xgf_trace("xgf_do_recycle now:%llu last_check:%llu fstb_act:%d",
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1847) 		now_ts, last_check2recycle_ts, fstb_active);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1848) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1849) 	xgf_lock(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1850) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1851) 	if (!fstb_active) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1852) 		xgf_reset_renders();
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1853) 		goto out;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1854) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1855) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1856) 	if (xgf_prev_dep_frames != xgf_dep_frames) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1857) 		if (xgf_dep_frames < XGF_DEP_FRAMES_MIN
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1858) 			|| xgf_dep_frames > XGF_DEP_FRAMES_MAX)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1859) 			xgf_dep_frames = XGF_DEP_FRAMES_MIN;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1860) 		xgf_prev_dep_frames = xgf_dep_frames;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1861) 		xgf_reset_renders();
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1862) 		goto out;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1863) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1864) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1865) 	if (diff < 0LL || diff < check_period)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1866) 		goto done;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1867) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1868) 	hlist_for_each_entry_safe(hw_iter, hw_t, &xgf_hw_events, hlist) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1869) 		diff = (long long)now_ts - (long long)hw_iter->head_ts;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1870) 		if (diff < check_period)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1871) 			continue;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1872) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1873) 		hlist_del(&hw_iter->hlist);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1874) 		xgf_free(hw_iter);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1875) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1876) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1877) out:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1878) 	last_check2recycle_ts = now_ts;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1879) done:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1880) 	xgf_unlock(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1881) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1882) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1883) static char *xgf_strcat(char *dest, const char *src,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1884) 	size_t buffersize, int *overflow)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1885) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1886) 	int i, j;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1887) 	int bufferbound = buffersize - 1;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1888) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1889) 	for (i = 0; dest[i] != '\0'; i++)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1890) 		;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1891) 	for (j = 0; src[j] != '\0'; j++) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1892) 		if ((i+j) < bufferbound)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1893) 			dest[i+j] = src[j];
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1894) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1895) 		if ((i+j) == bufferbound) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1896) 			*overflow = 1;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1897) 			break;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1898) 		}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1899) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1900) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1901) 	if (*overflow)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1902) 		dest[bufferbound] = '\0';
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1903) 	else
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1904) 		dest[i+j] = '\0';
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1905) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1906) 	return dest;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1907) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1908) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1909) static void xgf_log_trace(const char *fmt, ...)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1910) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1911) 	char log[1024];
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1912) 	va_list args;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1913) 	int len;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1914) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1915) 	va_start(args, fmt);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1916) 	len = vsnprintf(log, sizeof(log), fmt, args);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1917) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1918) 	if (unlikely(len == 1024))
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1919) 		log[1023] = '\0';
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1920) 	va_end(args);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1921) 	trace_xgf_log(log);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1922) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1923) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1924) static void xgf_print_debug_log(int rpid,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1925) 	struct xgf_render *render, unsigned long long runtime)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1926) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1927) 	char total_pid_list[1024] = {"\0"};
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1928) 	char pid[20] = {"\0"};
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1929) 	int overflow = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1930) 	int len = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1931) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1932) 	struct xgf_render_sector *xrs;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1933) 	struct hlist_node *s, *p;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1934) 	struct xgf_pid_rec *pids_iter;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1935) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1936) 	xgf_lockprove(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1937) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1938) 	hlist_for_each_entry_safe(xrs, s, &render->sector_head, hlist) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1939) 		if (strlen(total_pid_list) == 0)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1940) 			len = snprintf(pid, sizeof(pid), "%d", xrs->sector_id);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1941) 		else
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1942) 			len = snprintf(pid, sizeof(pid), "-%d", xrs->sector_id);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1943) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1944) 		if (len < 0 || len >= sizeof(pid))
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1945) 			goto error;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1946) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1947) 		overflow = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1948) 		xgf_strcat(total_pid_list, pid,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1949) 			sizeof(total_pid_list), &overflow);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1950) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1951) 		if (overflow)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1952) 			goto out;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1953) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1954) 		hlist_for_each_entry_safe(pids_iter, p,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1955) 			&xrs->path_head, hlist) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1956) 			len = snprintf(pid, sizeof(pid), ",%d", pids_iter->pid);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1957) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1958) 			if (len < 0 || len >= sizeof(pid))
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1959) 				goto error;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1960) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1961) 			overflow = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1962) 			xgf_strcat(total_pid_list, pid,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1963) 				sizeof(total_pid_list), &overflow);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1964) 			if (overflow)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1965) 				goto out;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1966) 		}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1967) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1968) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1969) out:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1970) 	if (overflow)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1971) 		xgf_log_trace("xgf_debug_log(of) r:%d runtime:%llu pid_list:%s",
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1972) 		rpid, runtime, total_pid_list);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1973) 	else
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1974) 		xgf_log_trace("xgf_debug_log r:%d runtime:%llu pid_list:%s",
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1975) 		rpid, runtime, total_pid_list);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1976) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1977) 	return;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1978) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1979) error:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1980) 	xgf_log_trace("xgf_debug_log(pid of) r:%d runtime:%llu",
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1981) 		rpid, runtime);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1982) 	return;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1983) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1984) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1985) static int xgf_enter_est_runtime(int rpid, struct xgf_render *render,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1986) 	unsigned long long *runtime, unsigned long long ts)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1987) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1988) 	int ret;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1989) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1990) 	WARN_ON(!xgf_est_runtime_fp);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1991) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1992) 	if (xgf_est_runtime_fp)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1993) 		ret = xgf_est_runtime_fp(rpid, render, runtime, ts);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1994) 	else
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1995) 		ret = -ENOENT;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1996) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1997) 	return ret;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1998) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 1999) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2000) static void xgf_get_runtime(pid_t tid, u64 *runtime)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2001) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2002) 	struct task_struct *p;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2003) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2004) 	if (unlikely(!tid))
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2005) 		return;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2006) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2007) 	rcu_read_lock();
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2008) 	p = find_task_by_vpid(tid);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2009) 	if (!p) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2010) 		xgf_trace(" %5d not found to erase", tid);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2011) 		rcu_read_unlock();
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2012) 		return;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2013) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2014) 	get_task_struct(p);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2015) 	rcu_read_unlock();
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2016) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2017) 	*runtime = (u64)task_sched_runtime(p);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2018) 	put_task_struct(p);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2019) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2020) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2021) static int xgf_get_spid(struct xgf_render *render)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2022) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2023) 	struct rb_root *r;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2024) 	struct rb_node *rbn;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2025) 	struct xgf_dep *iter;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2026) 	int len, ret = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2027) 	unsigned long long now_ts = xgf_get_time();
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2028) 	long long diff, scan_period;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2029) 	unsigned long long spid_runtime, t_spid_runtime;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2030) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2031) 	xgf_lockprove(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2032) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2033) 	if (xgf_spid_ck_period > NSEC_PER_SEC || xgf_spid_ck_period < 0)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2034) 		xgf_spid_ck_period = NSEC_PER_SEC;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2035) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2036) 	scan_period = xgf_spid_ck_period;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2037) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2038) 	diff = (long long)now_ts - (long long)last_update2spid_ts;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2039) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2040) 	if (diff < 0LL || diff < scan_period)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2041) 		return -1;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2042) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2043) 	/* reset and build spid list*/
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2044) 	if (xgf_cfg_spid) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2045) 		xgf_render_reset_wspid_list(render);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2046) 		xgf_render_setup_wspid_list(render);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2047) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2048) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2049) 	if (xgf_sp_name_id > 1 || xgf_sp_name_id < 0)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2050) 		xgf_sp_name_id = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2051) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2052) 	if (!xgf_sp_name_id)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2053) 		xgf_sp_name = SP_ALLOW_NAME;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2054) 	else
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2055) 		xgf_sp_name = SP_ALLOW_NAME2;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2056) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2057) 	len = strlen(xgf_sp_name);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2058) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2059) 	if (!len)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2060) 		return 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2061) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2062) 	if (xgf_sp_name[len - 1] == '\n') {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2063) 		len--;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2064) 		xgf_trace("xgf_sp_name len:%d has a change line terminal", len);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2065) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2066) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2067) 	spid_runtime = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2068) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2069) 	if (render->spid && xgf_sp_name_id)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2070) 		xgf_get_runtime(render->spid, &spid_runtime);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2071) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2072) 	r = &render->deps_list;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2073) 	for (rbn = rb_first(r); rbn != NULL; rbn = rb_next(rbn)) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2074) 		struct task_struct *tsk;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2075) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2076) 		iter = rb_entry(rbn, struct xgf_dep, rb_node);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2077) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2078) 		rcu_read_lock();
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2079) 		tsk = find_task_by_vpid(iter->tid);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2080) 		if (tsk)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2081) 			get_task_struct(tsk);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2082) 		rcu_read_unlock();
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2083) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2084) 		if (tsk) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2085) 			if ((tsk->tgid != render->parent)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2086) 				|| (task_pid_nr(tsk) == render->render))
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2087) 				goto tsk_out;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2088) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2089) 			if (!strncmp(tsk->comm, xgf_sp_name,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2090) 				len)) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2091) 				if (xgf_sp_name_id) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2092) 					t_spid_runtime = (u64)task_sched_runtime(tsk);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2093) 					if (t_spid_runtime > spid_runtime)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2094) 						ret = task_pid_nr(tsk);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2095) 				} else
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2096) 					ret = task_pid_nr(tsk);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2097) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2098) 				put_task_struct(tsk);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2099) 				goto out;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2100) 			}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2101) tsk_out:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2102) 			put_task_struct(tsk);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2103) 		}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2104) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2105) out:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2106) 	last_update2spid_ts = now_ts;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2107) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2108) 	if (!ret && render->spid && xgf_sp_name_id && spid_runtime)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2109) 		ret = render->spid;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2110) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2111) 	return ret;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2112) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2113) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2114) static void xgf_update_u_runtime_list(struct xgf_render *render,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2115) 	unsigned long long prev_qe_ts, unsigned long long qe_ts,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2116) 	unsigned long long pprev_u_runtime, unsigned long long prev_u_runtime)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2117) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2118) 	unsigned long long u_runtime;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2119) 	unsigned long long q2q_time;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2120) 	unsigned long long normal_u_runtime;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2121) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2122) 	if ((qe_ts <= prev_qe_ts) ||
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2123) 		(prev_u_runtime <= pprev_u_runtime) || !pprev_u_runtime)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2124) 		goto out;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2125) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2126) 	if (render->frame_count < UB_SKIP_FRAME)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2127) 		goto out;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2128) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2129) 	u_runtime = prev_u_runtime - pprev_u_runtime;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2130) 	q2q_time = qe_ts - prev_qe_ts;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2131) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2132) 	if (u_runtime > q2q_time)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2133) 		goto out;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2134) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2135) 	render->u_runtime[render->u_runtime_idx] = u_runtime;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2136) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2137) 	/* handle u_runtime extreme value */
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2138) 	normal_u_runtime = render->u_avg_runtime + 2*render->u_runtime_sd;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2139) 	if (u_runtime > normal_u_runtime &&
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2140) 		render->u_avg_runtime && render->u_runtime_sd)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2141) 		render->u_runtime[render->u_runtime_idx] = normal_u_runtime;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2142) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2143) 	render->u_runtime_idx++;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2144) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2145) 	if (render->u_runtime_idx == XGF_MAX_UFRMAES)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2146) 		render->u_runtime_idx = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2147) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2148) out:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2149) 	return;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2150) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2151) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2152) static unsigned long long xgf_sqrt(unsigned long long x)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2153) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2154) 	unsigned long long b, m, y = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2155) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2156) 	if (x <= 1)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2157) 		return x;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2158) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2159) 	m = 1UL << (__fls(x) & ~1UL);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2160) 	while (m != 0) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2161) 		b = y + m;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2162) 		y >>= 1;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2163) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2164) 		if (x >= b) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2165) 			x -= b;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2166) 			y += m;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2167) 		}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2168) 		m >>= 2;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2169) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2170) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2171) 	return y;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2172) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2173) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2174) static void xgf_calculate_u_avg2sd(struct xgf_render *render)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2175) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2176) 	int i, interval, divisor;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2177) 	unsigned long long diff, total, avg, stddev;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2178) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2179) 	if (render->frame_count < 2)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2180) 		return;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2181) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2182) 	/* First calculate the average */
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2183) 	divisor = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2184) 	total = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2185) 	if (render->frame_count <= XGF_MAX_UFRMAES)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2186) 		interval = render->frame_count - 1;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2187) 	else
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2188) 		interval = XGF_MAX_UFRMAES;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2189) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2190) 	for (i = 0; i < interval; i++) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2191) 		if (xgf_ull_multi_add_overflow(1, total, render->u_runtime[i])) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2192) 			total = ULLONG_MAX;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2193) 			divisor++;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2194) 			break;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2195) 		}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2196) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2197) 		total += render->u_runtime[i];
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2198) 		divisor++;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2199) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2200) 	if (divisor > 0) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2201) 		avg = div_u64(total, divisor);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2202) 		render->u_avg_runtime = avg;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2203) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2204) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2205) 	/* Then try to determine standard deviation */
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2206) 	stddev = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2207) 	for (i = 0; i < interval; i++) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2208) 		if (render->u_runtime[i] > avg)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2209) 			diff = render->u_runtime[i] - avg;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2210) 		else
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2211) 			diff = avg - render->u_runtime[i];
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2212) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2213) 		if ((xgf_ull_multi_add_overflow(0, diff, diff))
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2214) 			|| (xgf_ull_multi_add_overflow(1, stddev, (diff * diff)))) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2215) 			stddev = ULLONG_MAX;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2216) 			break;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2217) 		}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2218) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2219) 		stddev += diff * diff;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2220) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2221) 	if (divisor > 0) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2222) 		stddev = div_u64(stddev, divisor);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2223) 		stddev = xgf_sqrt(stddev);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2224) 		render->u_runtime_sd = stddev;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2225) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2226) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2227) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2228) int fpsgo_comp2xgf_qudeq_notify(int rpid, unsigned long long bufID, int cmd,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2229) 	unsigned long long *run_time, unsigned long long *mid,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2230) 	unsigned long long ts)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2231) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2232) 	int ret = XGF_NOTIFY_OK;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2233) 	struct xgf_render *r, **rrender;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2234) 	struct xgf_hw_rec *hr_iter;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2235) 	struct hlist_node *hr;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2236) 	unsigned long long raw_runtime = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2237) 	unsigned long long u_runtime = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2238) 	int new_spid;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2239) 	unsigned long long t_dequeue_time = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2240) 	int do_extra_sub = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2241) 	unsigned long long q2q_time = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2242) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2243) 	if (rpid <= 0 || ts == 0)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2244) 		return XGF_PARAM_ERR;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2245) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2246) 	xgf_lock(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2247) 	if (!xgf_is_enable()) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2248) 		xgf_unlock(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2249) 		return XGF_DISABLE;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2250) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2251) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2252) 	switch (cmd) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2253) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2254) 	case XGF_QUEUE_START:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2255) 		rrender = &r;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2256) 		if (xgf_get_render(rpid, bufID, rrender, 0)) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2257) 			ret = XGF_THREAD_NOT_FOUND;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2258) 			goto qudeq_notify_err;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2259) 		}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2260) 		r->queue.start_ts = ts;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2261) 		xgf_reset_render_sector(r);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2262) 		break;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2263) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2264) 	case XGF_QUEUE_END:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2265) 		rrender = &r;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2266) 		if (xgf_get_render(rpid, bufID, rrender, 1)) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2267) 			ret = XGF_THREAD_NOT_FOUND;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2268) 			goto qudeq_notify_err;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2269) 		}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2270) 		if (xgf_uboost) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2271) 			xgf_get_runtime(r->parent, &u_runtime);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2272) 			/* store pre-frmae u runtime */
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2273) 			xgf_update_u_runtime_list(r, r->queue.end_ts,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2274) 				ts, r->pre_u_runtime, u_runtime);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2275) 			xgf_calculate_u_avg2sd(r);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2276) 			r->pre_u_runtime = u_runtime;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2277) 		}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2278) 		q2q_time = ts - r->queue.end_ts;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2279) 		r->queue.end_ts = ts;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2280) 		cur_xgf_extra_sub = xgf_extra_sub;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2281) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2282) 		new_spid = xgf_get_spid(r);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2283) 		if (new_spid != -1) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2284) 			xgf_trace("xgf spid:%d => %d", r->spid, new_spid);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2285) 			r->spid = new_spid;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2286) 			fpsgo_systrace_c_fbt(rpid, bufID, new_spid, "spid");
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2287) 		}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2288) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2289) 		t_dequeue_time = r->deque.end_ts - r->deque.start_ts;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2290) 		if (r->deque.start_ts && r->deque.end_ts
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2291) 			&& (r->deque.end_ts > r->deque.start_ts)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2292) 			&& (t_dequeue_time > 2500000)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2293) 			&& !cur_xgf_extra_sub && !xgf_force_no_extra_sub) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2294) 			do_extra_sub = 1;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2295) 			cur_xgf_extra_sub = 1;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2296) 			xgf_trace("xgf extra_sub:%d => %llu", rpid, t_dequeue_time);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2297) 		}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2298) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2299) 		ret = xgf_enter_est_runtime(rpid, r, &raw_runtime, ts);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2300) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2301) 		if (do_extra_sub)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2302) 			cur_xgf_extra_sub = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2303) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2304) 		if (!raw_runtime)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2305) 			*run_time = raw_runtime;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2306) 		else {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2307) 			xgf_trace("xgf raw_runtime:%llu q2qtime:%llu", raw_runtime, q2q_time);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2308) 			/* error handling for raw_t_cpu */
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2309) 			if (q2q_time && raw_runtime > q2q_time)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2310) 				raw_runtime = q2q_time;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2311) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2312) 			r->ema_runtime =
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2313) 				xgf_ema_cal(raw_runtime, r->ema_runtime);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2314) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2315) 			*run_time = r->ema_runtime;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2316) 		}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2317) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2318) 		fpsgo_systrace_c_fbt(rpid, bufID, raw_runtime, "raw_t_cpu");
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2319) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2320) 		/* hw event for fbt */
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2321) 		hlist_for_each_entry_safe(hr_iter, hr, &r->hw_head, hlist) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2322) 			if (hr_iter->hw_type == PER_FRAME)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2323) 				*mid = hr_iter->mid;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2324) 			xgf_trace("xgf hw mid:%llu event_type:%d hw_type:%d",
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2325) 			hr_iter->mid, hr_iter->event_type, hr_iter->hw_type);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2326) 		}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2327) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2328) 		xgf_print_debug_log(rpid, r, raw_runtime);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2329) 		break;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2330) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2331) 	case XGF_DEQUEUE_START:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2332) 		rrender = &r;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2333) 		if (xgf_get_render(rpid, bufID, rrender, 0)) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2334) 			ret = XGF_THREAD_NOT_FOUND;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2335) 			goto qudeq_notify_err;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2336) 		}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2337) 		r->deque.start_ts = ts;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2338) 		break;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2339) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2340) 	case XGF_DEQUEUE_END:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2341) 		rrender = &r;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2342) 		if (xgf_get_render(rpid, bufID, rrender, 0)) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2343) 			ret = XGF_THREAD_NOT_FOUND;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2344) 			goto qudeq_notify_err;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2345) 		}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2346) 		r->deque.end_ts = ts;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2347) 		break;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2348) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2349) 	default:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2350) 		ret = XGF_PARAM_ERR;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2351) 		break;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2352) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2353) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2354) qudeq_notify_err:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2355) 	xgf_trace("xgf result:%d at rpid:%d cmd:%d", ret, rpid, cmd);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2356) 	xgf_unlock(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2357) 	return ret;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2358) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2359) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2360) void xgf_set_logical_render_runtime(int pid, unsigned long long bufID,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2361) 	unsigned long long l_runtime, unsigned long long r_runtime) { }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2362) EXPORT_SYMBOL(xgf_set_logical_render_runtime);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2363) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2364) void xgf_set_logical_render_info(int pid, unsigned long long bufID,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2365) 	int *l_arr, int l_num, int *r_arr, int r_num,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2366) 	unsigned long long l_start_ts,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2367) 	unsigned long long f_start_ts) { }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2368) EXPORT_SYMBOL(xgf_set_logical_render_info);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2369) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2370) void xgf_set_timer_info(int pid, unsigned long long bufID, int hrtimer_pid, int hrtimer_flag,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2371) 	unsigned long long hrtimer_ts, unsigned long long prev_queue_end_ts)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2372) { }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2373) EXPORT_SYMBOL(xgf_set_timer_info);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2374) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2375) static ssize_t deplist_show(struct kobject *kobj,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2376) 		struct kobj_attribute *attr,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2377) 		char *buf)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2378) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2379) 	struct xgf_render *r_iter;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2380) 	struct hlist_node *r_tmp;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2381) 	struct rb_root *r;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2382) 	struct xgf_dep *iter;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2383) 	struct rb_node *n;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2384) 	char temp[FPSGO_SYSFS_MAX_BUFF_SIZE] = "";
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2385) 	int pos = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2386) 	int length;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2387) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2388) 	xgf_lock(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2389) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2390) 	hlist_for_each_entry_safe(r_iter, r_tmp, &xgf_renders, hlist) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2391) 		r = &r_iter->deps_list;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2392) 		for (n = rb_first(r); n != NULL; n = rb_next(n)) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2393) 			iter = rb_entry(n, struct xgf_dep, rb_node);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2394) 			length = scnprintf(temp + pos,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2395) 				FPSGO_SYSFS_MAX_BUFF_SIZE - pos,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2396) 				"rtid:%d bid:0x%llx itid:%d idx:%d\n",
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2397) 				r_iter->render, r_iter->bufID,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2398) 				iter->tid, iter->frame_idx);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2399) 			pos += length;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2400) 		}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2401) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2402) 		r = &r_iter->out_deps_list;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2403) 		for (n = rb_first(r); n != NULL; n = rb_next(n)) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2404) 			iter = rb_entry(n, struct xgf_dep, rb_node);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2405) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2406) 			length = scnprintf(temp + pos,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2407) 				FPSGO_SYSFS_MAX_BUFF_SIZE - pos,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2408) 				"rtid:%d bid:0x%llx otid:%d idx:%d\n",
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2409) 				 r_iter->render, r_iter->bufID,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2410) 				 iter->tid, iter->frame_idx);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2411) 			pos += length;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2412) 		}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2413) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2414) 		r = &r_iter->prev_deps_list;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2415) 		for (n = rb_first(r); n != NULL; n = rb_next(n)) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2416) 			iter = rb_entry(n, struct xgf_dep, rb_node);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2417) 			length = scnprintf(temp + pos,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2418) 				FPSGO_SYSFS_MAX_BUFF_SIZE - pos,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2419) 				"rtid:%d bid:0x%llx ptid:%d idx:%d\n",
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2420) 				 r_iter->render, r_iter->bufID,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2421) 				 iter->tid, iter->frame_idx);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2422) 			pos += length;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2423) 		}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2424) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2425) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2426) 	xgf_unlock(__func__);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2427) 	return scnprintf(buf, PAGE_SIZE, "%s", temp);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2428) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2429) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2430) struct xgf_trace_event *xgf_event_data;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2431) EXPORT_SYMBOL(xgf_event_data);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2432) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2433) static int xgf_nr_cpus __read_mostly;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2434) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2435) void *xgf_event_index;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2436) EXPORT_SYMBOL(xgf_event_index);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2437) void *xgf_ko_enabled;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2438) EXPORT_SYMBOL(xgf_ko_enabled);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2439) int xgf_max_events;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2440) EXPORT_SYMBOL(xgf_max_events);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2441) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2442) struct fstb_trace_event *fstb_event_data;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2443) EXPORT_SYMBOL(fstb_event_data);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2444) atomic_t fstb_event_data_idx;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2445) EXPORT_SYMBOL(fstb_event_data_idx);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2446) int fstb_event_buffer_size;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2447) EXPORT_SYMBOL(fstb_event_buffer_size);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2448) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2449) #define MAX_XGF_EVENTS (xgf_max_events)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2450) #define MAX_EVENT_NUM fstb_event_buffer_size
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2451) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2452) static void xgf_buffer_update(int cpu, int event, int data, int note,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2453) 				unsigned long long ts)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2454) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2455) 	int index;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2456) 	struct xgf_trace_event *xte;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2457) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2458) 	if (!xgf_atomic_read(xgf_ko_enabled))
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2459) 		return;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2460) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2461) Reget:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2462) 	index = xgf_atomic_inc_return(xgf_event_index);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2463) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2464) 	/* protection for if xgf_nr_cpus in error condition */
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2465) 	if (unlikely(index < 0)) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2466) 		xgf_atomic_set(xgf_event_index, 0);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2467) 		return;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2468) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2469) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2470) 	/* prevent the thread that supposed to set */
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2471) 	/* xgf_event_index to zero is preempted and then cases HWT */
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2472) 	if (unlikely(index > (MAX_XGF_EVENTS + (xgf_nr_cpus << 1)))) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2473) 		xgf_atomic_set(xgf_event_index, 0);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2474) 		return;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2475) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2476) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2477) 	if (unlikely(index == MAX_XGF_EVENTS))
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2478) 		xgf_atomic_set(xgf_event_index, 0);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2479) 	else if (unlikely(index > MAX_XGF_EVENTS))
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2480) 		goto Reget;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2481) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2482) 	index -= 1;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2483) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2484) 	xte = &xgf_event_data[index];
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2485) 	xte->ts = ts;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2486) 	xte->cpu = cpu;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2487) 	xte->event = event;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2488) 	xte->note = note;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2489) 	switch (event) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2490) 	case SCHED_SWITCH:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2491) 		xte->prev_pid = data;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2492) 		break;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2493) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2494) 	case SCHED_WAKEUP:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2495) 		xte->pid = data;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2496) 		break;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2497) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2498) 	case IPI_RAISE:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2499) 		xte->target_cpu = data;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2500) 		break;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2501) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2502) 	case IRQ_ENTRY:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2503) 	case IRQ_EXIT:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2504) 	case SOFTIRQ_ENTRY:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2505) 	case SOFTIRQ_EXIT:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2506) 		xte->irqnr = data;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2507) 		break;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2508) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2509) 	default: // IPI_ENTRY, IPI_EXIT
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2510) 		xte->none = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2511) 		break;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2512) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2513) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2514) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2515) static void xgf_irq_handler_entry_tracer(void *ignore,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2516) 					int irqnr,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2517) 					struct irqaction *irq_action)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2518) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2519) 	unsigned long long ts = xgf_get_time();
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2520) 	int c_wake_cpu = xgf_get_task_wake_cpu(current);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2521) 	int c_pid = xgf_get_task_pid(current);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2522) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2523) 	xgf_buffer_update(c_wake_cpu, IRQ_ENTRY, irqnr, c_pid, ts);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2524) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2525) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2526) static void xgf_irq_handler_exit_tracer(void *ignore,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2527) 					int irqnr,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2528) 					struct irqaction *irq_action,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2529) 					int ret)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2530) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2531) 	unsigned long long ts = xgf_get_time();
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2532) 	int c_wake_cpu = xgf_get_task_wake_cpu(current);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2533) 	int c_pid = xgf_get_task_pid(current);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2534) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2535) 	xgf_buffer_update(c_wake_cpu, IRQ_EXIT, irqnr, c_pid, ts);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2536) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2537) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2538) static void xgf_softirq_entry_tracer(void *ignore, unsigned int vec_nr)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2539) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2540) 	unsigned long long ts = xgf_get_time();
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2541) 	int c_wake_cpu = xgf_get_task_wake_cpu(current);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2542) 	int c_pid = xgf_get_task_pid(current);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2543) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2544) 	xgf_buffer_update(c_wake_cpu, SOFTIRQ_ENTRY, vec_nr, c_pid, ts);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2545) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2546) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2547) static void xgf_softirq_exit_tracer(void *ignore, unsigned int vec_nr)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2548) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2549) 	unsigned long long ts = xgf_get_time();
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2550) 	int c_wake_cpu = xgf_get_task_wake_cpu(current);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2551) 	int c_pid = xgf_get_task_pid(current);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2552) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2553) 	xgf_buffer_update(c_wake_cpu, SOFTIRQ_EXIT, vec_nr, c_pid, ts);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2554) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2555) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2556) static void xgf_ipi_raise_tracer(void *ignore, const struct cpumask *mask,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2557) 				const char *reason)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2558) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2559) 	unsigned int i;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2560) 	unsigned long long ts = xgf_get_time();
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2561) 	int c_wake_cpu = xgf_get_task_wake_cpu(current);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2562) 	int c_pid = xgf_get_task_pid(current);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2563) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2564) 	if (xgf_nr_cpus == 1)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2565) 		xgf_buffer_update(c_wake_cpu, IPI_RAISE, 0, c_pid, ts);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2566) 	else {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2567) 		for (i = -1; i = xgf_cpumask_next(i, mask), i < xgf_nr_cpus;)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2568) 			xgf_buffer_update(c_wake_cpu, IPI_RAISE, i, c_pid, ts);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2569) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2570) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2571) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2572) static void xgf_ipi_entry_tracer(void *ignore, const char *reason)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2573) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2574) 	unsigned long long ts = xgf_get_time();
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2575) 	int c_wake_cpu = xgf_get_task_wake_cpu(current);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2576) 	int c_pid = xgf_get_task_pid(current);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2577) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2578) 	xgf_buffer_update(c_wake_cpu, IPI_ENTRY, 0, c_pid, ts);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2579) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2580) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2581) static void xgf_ipi_exit_tracer(void *ignore, const char *reason)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2582) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2583) 	unsigned long long ts = xgf_get_time();
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2584) 	int c_wake_cpu = xgf_get_task_wake_cpu(current);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2585) 	int c_pid = xgf_get_task_pid(current);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2586) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2587) 	xgf_buffer_update(c_wake_cpu, IPI_EXIT, 0, c_pid, ts);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2588) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2589) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2590) static void xgf_sched_wakeup_tracer(void *ignore, struct task_struct *p)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2591) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2592) 	unsigned long long ts = xgf_get_time();
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2593) 	int c_wake_cpu = xgf_get_task_wake_cpu(current);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2594) 	int c_pid = xgf_get_task_pid(current);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2595) 	int p_pid = xgf_get_task_pid(p);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2596) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2597) 	xgf_buffer_update(c_wake_cpu, SCHED_WAKEUP, p_pid, c_pid, ts);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2598) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2599) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2600) static void xgf_sched_wakeup_new_tracer(void *ignore, struct task_struct *p)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2601) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2602) 	unsigned long long ts = xgf_get_time();
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2603) 	int c_wake_cpu = xgf_get_task_wake_cpu(current);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2604) 	int c_pid = xgf_get_task_pid(current);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2605) 	int p_pid = xgf_get_task_pid(p);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2606) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2607) 	xgf_buffer_update(c_wake_cpu, SCHED_WAKEUP, p_pid, c_pid, ts);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2608) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2609) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2610) static inline long xgf_trace_sched_switch_state(bool preempt,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2611) 				struct task_struct *p)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2612) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2613) 	long state = xgf_get_task_state(p);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2614) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2615) 	if (preempt)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2616) 		state = TASK_RUNNING | TASK_STATE_MAX;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2617) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2618) 	return state;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2619) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2620) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2621) static void xgf_sched_switch_tracer(void *ignore,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2622) 				bool preempt,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2623) 				struct task_struct *prev,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2624) 				struct task_struct *next)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2625) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2626) 	long prev_state;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2627) 	long temp_state;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2628) 	int skip = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2629) 	unsigned long long ts = xgf_get_time();
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2630) 	int c_wake_cpu = xgf_get_task_wake_cpu(current);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2631) 	int prev_pid = xgf_get_task_pid(prev);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2632) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2633) 	prev_state = xgf_trace_sched_switch_state(preempt, prev);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2634) 	temp_state = prev_state & (TASK_STATE_MAX-1);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2635) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2636) 	if (!temp_state)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2637) 		skip = 1;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2638) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2639) 	xgf_buffer_update(c_wake_cpu, SCHED_SWITCH, prev_pid, skip, ts);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2640) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2641) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2642) static void xgf_sched_waking_tracer(void *ignore, struct task_struct *p) { }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2643) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2644) static void xgf_hrtimer_expire_entry_tracer(void *ignore,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2645) 	struct hrtimer *hrtimer, ktime_t *now) { }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2646) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2647) static void xgf_hrtimer_expire_exit_tracer(void *ignore, struct hrtimer *hrtimer) { }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2648) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2649) struct tracepoints_table {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2650) 	const char *name;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2651) 	void *func;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2652) 	struct tracepoint *tp;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2653) 	bool registered;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2654) };
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2655) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2656) static struct tracepoints_table xgf_tracepoints[] = {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2657) 	{.name = "irq_handler_entry", .func = xgf_irq_handler_entry_tracer},
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2658) 	{.name = "irq_handler_exit", .func = xgf_irq_handler_exit_tracer},
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2659) 	{.name = "softirq_entry", .func = xgf_softirq_entry_tracer},
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2660) 	{.name = "softirq_exit", .func = xgf_softirq_exit_tracer},
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2661) 	{.name = "ipi_raise", .func = xgf_ipi_raise_tracer},
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2662) 	{.name = "ipi_entry", .func = xgf_ipi_entry_tracer},
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2663) 	{.name = "ipi_exit", .func = xgf_ipi_exit_tracer},
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2664) 	{.name = "sched_wakeup", .func = xgf_sched_wakeup_tracer},
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2665) 	{.name = "sched_wakeup_new", .func = xgf_sched_wakeup_new_tracer},
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2666) 	{.name = "sched_switch", .func = xgf_sched_switch_tracer},
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2667) 	{.name = "sched_waking", .func = xgf_sched_waking_tracer},
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2668) 	{.name = "hrtimer_expire_entry", .func = xgf_hrtimer_expire_entry_tracer},
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2669) 	{.name = "hrtimer_expire_exit", .func = xgf_hrtimer_expire_exit_tracer},
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2670) };
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2671) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2672) #define FOR_EACH_INTEREST_MAX \
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2673) 	(sizeof(xgf_tracepoints) / sizeof(struct tracepoints_table))
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2674) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2675) #define FOR_EACH_INTEREST(i) \
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2676) 	for (i = 0; i < FOR_EACH_INTEREST_MAX; i++)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2677) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2678) static void lookup_tracepoints(struct tracepoint *tp, void *ignore)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2679) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2680) 	int i;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2681) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2682) 	FOR_EACH_INTEREST(i) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2683) 		if (strcmp(xgf_tracepoints[i].name, tp->name) == 0)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2684) 			xgf_tracepoints[i].tp = tp;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2685) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2686) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2687) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2688) static void xgf_cleanup(void)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2689) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2690) 	int i;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2691) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2692) 	FOR_EACH_INTEREST(i) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2693) 		if (xgf_tracepoints[i].registered) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2694) 			xgf_tracepoint_probe_unregister(xgf_tracepoints[i].tp,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2695) 						xgf_tracepoints[i].func, NULL);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2696) 			xgf_tracepoints[i].registered = false;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2697) 		}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2698) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2699) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2700) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2701) static void __nocfi xgf_tracing_register(void)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2702) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2703) 	int ret;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2704) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2705) 	xgf_nr_cpus = xgf_num_possible_cpus();
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2706) 	xgf_atomic_set(xgf_event_index, 0);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2707) 	atomic_set(&fstb_event_data_idx, 0);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2708) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2709) 	/* xgf_irq_handler_entry_tracer */
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2710) 	ret = xgf_tracepoint_probe_register(xgf_tracepoints[0].tp,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2711) 						xgf_tracepoints[0].func,  NULL);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2712) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2713) 	if (ret) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2714) 		pr_info("irq_handler_entry: Couldn't activate tracepoint probe to irq_handler_entry\n");
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2715) 		goto fail_reg_irq_handler_entry;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2716) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2717) 	xgf_tracepoints[0].registered = true;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2718) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2719) 	/* xgf_irq_handler_exit_tracer */
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2720) 	ret = xgf_tracepoint_probe_register(xgf_tracepoints[1].tp,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2721) 						xgf_tracepoints[1].func,  NULL);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2722) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2723) 	if (ret) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2724) 		pr_info("irq_handler_exit: Couldn't activate tracepoint probe to irq_handler_exit\n");
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2725) 		goto fail_reg_irq_handler_exit;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2726) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2727) 	xgf_tracepoints[1].registered = true;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2728) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2729) 	/* xgf_softirq_entry_tracer */
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2730) 	ret = xgf_tracepoint_probe_register(xgf_tracepoints[2].tp,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2731) 						xgf_tracepoints[2].func,  NULL);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2732) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2733) 	if (ret) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2734) 		pr_info("softirq_entry: Couldn't activate tracepoint probe to softirq_entry\n");
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2735) 		goto fail_reg_softirq_entry;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2736) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2737) 	xgf_tracepoints[2].registered = true;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2738) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2739) 	/* xgf_softirq_exit_tracer */
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2740) 	ret = xgf_tracepoint_probe_register(xgf_tracepoints[3].tp,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2741) 						xgf_tracepoints[3].func,  NULL);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2742) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2743) 	if (ret) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2744) 		pr_info("softirq_exit: Couldn't activate tracepoint probe to softirq_exit\n");
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2745) 		goto fail_reg_softirq_exit;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2746) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2747) 	xgf_tracepoints[3].registered = true;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2748) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2749) 	/* xgf_ipi_raise_tracer */
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2750) 	ret = xgf_tracepoint_probe_register(xgf_tracepoints[4].tp,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2751) 						xgf_tracepoints[4].func,  NULL);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2752) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2753) 	if (ret) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2754) 		pr_info("ipi_raise: Couldn't activate tracepoint probe to ipi_raise\n");
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2755) 		goto fail_reg_ipi_raise;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2756) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2757) 	xgf_tracepoints[4].registered = true;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2758) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2759) 	/* xgf_ipi_entry_tracer */
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2760) 	ret = xgf_tracepoint_probe_register(xgf_tracepoints[5].tp,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2761) 						xgf_tracepoints[5].func,  NULL);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2762) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2763) 	if (ret) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2764) 		pr_info("ipi_entry: Couldn't activate tracepoint probe to ipi_entry\n");
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2765) 		goto fail_reg_ipi_entry;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2766) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2767) 	xgf_tracepoints[5].registered = true;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2768) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2769) 	/* xgf_ipi_exit_tracer */
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2770) 	ret = xgf_tracepoint_probe_register(xgf_tracepoints[6].tp,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2771) 						xgf_tracepoints[6].func,  NULL);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2772) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2773) 	if (ret) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2774) 		pr_info("ipi_exit: Couldn't activate tracepoint probe to ipi_exit\n");
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2775) 		goto fail_reg_ipi_exit;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2776) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2777) 	xgf_tracepoints[6].registered = true;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2778) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2779) 	/* xgf_sched_wakeup_tracer */
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2780) 	ret = xgf_tracepoint_probe_register(xgf_tracepoints[7].tp,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2781) 						xgf_tracepoints[7].func,  NULL);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2782) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2783) 	if (ret) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2784) 		pr_info("wakeup trace: Couldn't activate tracepoint probe to kernel_sched_wakeup\n");
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2785) 		goto fail_reg_sched_wakeup;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2786) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2787) 	xgf_tracepoints[7].registered = true;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2788) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2789) 	/* xgf_sched_wakeup_new_tracer */
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2790) 	ret = xgf_tracepoint_probe_register(xgf_tracepoints[8].tp,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2791) 						xgf_tracepoints[8].func,  NULL);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2792) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2793) 	if (ret) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2794) 		pr_info("wakeup trace: Couldn't activate tracepoint probe to kernel_sched_wakeup_new\n");
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2795) 		goto fail_reg_sched_wakeup_new;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2796) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2797) 	xgf_tracepoints[8].registered = true;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2798) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2799) 	/* xgf_sched_switch_tracer */
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2800) 	ret = xgf_tracepoint_probe_register(xgf_tracepoints[9].tp,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2801) 						xgf_tracepoints[9].func,  NULL);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2802) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2803) 	if (ret) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2804) 		pr_info("sched trace: Couldn't activate tracepoint probe to kernel_sched_switch\n");
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2805) 		goto fail_reg_sched_switch;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2806) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2807) 	xgf_tracepoints[9].registered = true;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2808) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2809) 	/* xgf_sched_waking_tracer */
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2810) 	ret = xgf_tracepoint_probe_register(xgf_tracepoints[10].tp,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2811) 						xgf_tracepoints[10].func,  NULL);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2812) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2813) 	if (ret) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2814) 		pr_info("sched trace: Couldn't activate tracepoint probe to kernel_sched_waking\n");
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2815) 		goto fail_reg_sched_waking;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2816) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2817) 	xgf_tracepoints[10].registered = true;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2818) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2819) 	/* xgf_hrtimer_expire_entry_tracer */
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2820) 	ret = xgf_tracepoint_probe_register(xgf_tracepoints[11].tp,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2821) 						xgf_tracepoints[11].func,  NULL);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2822) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2823) 	if (ret) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2824) 		pr_info("hrtimer_entry trace: Couldn't activate tracepoint probe to kernel_hrtimer_expire_entry\n");
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2825) 		goto fail_reg_hrtimer_expire_entry;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2826) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2827) 	xgf_tracepoints[11].registered = true;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2828) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2829) 	/* xgf_hrtimer_expire_exit_tracer */
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2830) 	ret = xgf_tracepoint_probe_register(xgf_tracepoints[12].tp,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2831) 						xgf_tracepoints[12].func,  NULL);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2832) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2833) 	if (ret) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2834) 		pr_info("hrtimer_exit trace: Couldn't activate tracepoint probe to kernel_hrtimer_expire_exit\n");
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2835) 		goto fail_reg_hrtimer_expire_exit;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2836) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2837) 	xgf_tracepoints[12].registered = true;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2838) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2839) 	xgf_atomic_set(xgf_event_index, 0);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2840) 	atomic_set(&fstb_event_data_idx, 0);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2841) 	return; /* successful registered all */
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2842) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2843) fail_reg_hrtimer_expire_exit:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2844) 	xgf_tracepoint_probe_unregister(xgf_tracepoints[12].tp,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2845) 					xgf_tracepoints[12].func,  NULL);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2846) fail_reg_hrtimer_expire_entry:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2847) 	xgf_tracepoint_probe_unregister(xgf_tracepoints[11].tp,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2848) 					xgf_tracepoints[11].func,  NULL);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2849) fail_reg_sched_waking:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2850) 	xgf_tracepoint_probe_unregister(xgf_tracepoints[10].tp,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2851) 					xgf_tracepoints[10].func,  NULL);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2852) fail_reg_sched_switch:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2853) 	xgf_tracepoint_probe_unregister(xgf_tracepoints[9].tp,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2854) 					xgf_tracepoints[9].func,  NULL);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2855) 	xgf_tracepoints[9].registered = false;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2856) fail_reg_sched_wakeup_new:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2857) 	xgf_tracepoint_probe_unregister(xgf_tracepoints[8].tp,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2858) 					xgf_tracepoints[8].func,  NULL);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2859) 	xgf_tracepoints[8].registered = false;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2860) fail_reg_sched_wakeup:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2861) 	xgf_tracepoint_probe_unregister(xgf_tracepoints[7].tp,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2862) 					xgf_tracepoints[7].func,  NULL);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2863) 	xgf_tracepoints[7].registered = false;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2864) fail_reg_ipi_exit:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2865) 	xgf_tracepoint_probe_unregister(xgf_tracepoints[6].tp,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2866) 					xgf_tracepoints[6].func,  NULL);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2867) 	xgf_tracepoints[6].registered = false;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2868) fail_reg_ipi_entry:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2869) 	xgf_tracepoint_probe_unregister(xgf_tracepoints[5].tp,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2870) 					xgf_tracepoints[5].func,  NULL);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2871) 	xgf_tracepoints[5].registered = false;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2872) fail_reg_ipi_raise:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2873) 	xgf_tracepoint_probe_unregister(xgf_tracepoints[4].tp,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2874) 					xgf_tracepoints[4].func,  NULL);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2875) 	xgf_tracepoints[4].registered = false;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2876) fail_reg_softirq_exit:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2877) 	xgf_tracepoint_probe_unregister(xgf_tracepoints[3].tp,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2878) 					xgf_tracepoints[3].func,  NULL);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2879) 	xgf_tracepoints[3].registered = false;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2880) fail_reg_softirq_entry:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2881) 	xgf_tracepoint_probe_unregister(xgf_tracepoints[2].tp,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2882) 					xgf_tracepoints[2].func,  NULL);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2883) 	xgf_tracepoints[2].registered = false;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2884) fail_reg_irq_handler_exit:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2885) 	xgf_tracepoint_probe_unregister(xgf_tracepoints[1].tp,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2886) 					xgf_tracepoints[1].func,  NULL);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2887) 	xgf_tracepoints[1].registered = false;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2888) fail_reg_irq_handler_entry:
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2889) 	xgf_tracepoint_probe_unregister(xgf_tracepoints[0].tp,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2890) 					xgf_tracepoints[0].func,  NULL);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2891) 	xgf_tracepoints[0].registered = false;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2892) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2893) 	xgf_atomic_set(xgf_ko_enabled, 0);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2894) 	xgf_atomic_set(xgf_event_index, 0);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2895) 	atomic_set(&fstb_event_data_idx, 0);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2896) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2897) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2898) static void __nocfi xgf_tracing_unregister(void)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2899) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2900) 	xgf_tracepoint_probe_unregister(xgf_tracepoints[0].tp,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2901) 					xgf_tracepoints[0].func,  NULL);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2902) 	xgf_tracepoints[0].registered = false;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2903) 	xgf_tracepoint_probe_unregister(xgf_tracepoints[1].tp,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2904) 					xgf_tracepoints[1].func,  NULL);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2905) 	xgf_tracepoints[1].registered = false;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2906) 	xgf_tracepoint_probe_unregister(xgf_tracepoints[2].tp,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2907) 					xgf_tracepoints[2].func,  NULL);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2908) 	xgf_tracepoints[2].registered = false;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2909) 	xgf_tracepoint_probe_unregister(xgf_tracepoints[3].tp,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2910) 					xgf_tracepoints[3].func,  NULL);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2911) 	xgf_tracepoints[3].registered = false;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2912) 	xgf_tracepoint_probe_unregister(xgf_tracepoints[4].tp,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2913) 					xgf_tracepoints[4].func,  NULL);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2914) 	xgf_tracepoints[4].registered = false;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2915) 	xgf_tracepoint_probe_unregister(xgf_tracepoints[5].tp,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2916) 					xgf_tracepoints[5].func,  NULL);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2917) 	xgf_tracepoints[5].registered = false;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2918) 	xgf_tracepoint_probe_unregister(xgf_tracepoints[6].tp,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2919) 					xgf_tracepoints[6].func,  NULL);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2920) 	xgf_tracepoints[6].registered = false;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2921) 	xgf_tracepoint_probe_unregister(xgf_tracepoints[7].tp,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2922) 					xgf_tracepoints[7].func,  NULL);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2923) 	xgf_tracepoints[7].registered = false;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2924) 	xgf_tracepoint_probe_unregister(xgf_tracepoints[8].tp,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2925) 					xgf_tracepoints[8].func,  NULL);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2926) 	xgf_tracepoints[8].registered = false;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2927) 	xgf_tracepoint_probe_unregister(xgf_tracepoints[9].tp,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2928) 					xgf_tracepoints[9].func,  NULL);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2929) 	xgf_tracepoints[9].registered = false;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2930) 	xgf_tracepoint_probe_unregister(xgf_tracepoints[10].tp,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2931) 					xgf_tracepoints[10].func,  NULL);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2932) 	xgf_tracepoints[10].registered = false;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2933) 	xgf_tracepoint_probe_unregister(xgf_tracepoints[11].tp,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2934) 					xgf_tracepoints[11].func,  NULL);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2935) 	xgf_tracepoints[11].registered = false;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2936) 	xgf_tracepoint_probe_unregister(xgf_tracepoints[12].tp,
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2937) 					xgf_tracepoints[12].func,  NULL);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2938) 	xgf_tracepoints[12].registered = false;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2939) 	xgf_atomic_set(xgf_event_index, 0);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2940) 	atomic_set(&fstb_event_data_idx, 0);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2941) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2942) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2943) int xgf_stat_xchg(int xgf_enable)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2944) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2945) 	int ret = -1;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2946) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2947) 	if (xgf_enable) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2948) 		xgf_tracing_register();
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2949) 		ret = 1;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2950) 		xgf_atomic_set(xgf_ko_enabled, 1);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2951) 	} else {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2952) 		xgf_tracing_unregister();
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2953) 		ret = 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2954) 		xgf_atomic_set(xgf_ko_enabled, 0);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2955) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2956) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2957) 	return ret;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2958) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2959) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2960) int __init init_xgf_ko(void)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2961) {
0000000000000 (Not Committed Yet 2025-09-18 19:28:43 -0300 2962)         int i;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2963) 
0000000000000 (Not Committed Yet 2025-09-18 19:28:43 -0300 2964)         for_each_kernel_tracepoint(lookup_tracepoints, NULL);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2965) 
0000000000000 (Not Committed Yet 2025-09-18 19:28:43 -0300 2966)         FOR_EACH_INTEREST(i) {
0000000000000 (Not Committed Yet 2025-09-18 19:28:43 -0300 2967)                 if (xgf_tracepoints[i].tp == NULL) {
0000000000000 (Not Committed Yet 2025-09-18 19:28:43 -0300 2968)                         pr_debug("XGF KO Error, %s not found\n",
0000000000000 (Not Committed Yet 2025-09-18 19:28:43 -0300 2969)                                         xgf_tracepoints[i].name);
0000000000000 (Not Committed Yet 2025-09-18 19:28:43 -0300 2970)                         xgf_cleanup();
0000000000000 (Not Committed Yet 2025-09-18 19:28:43 -0300 2971)                         return -1;
0000000000000 (Not Committed Yet 2025-09-18 19:28:43 -0300 2972)                 }
0000000000000 (Not Committed Yet 2025-09-18 19:28:43 -0300 2973)         }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2974) 
0000000000000 (Not Committed Yet 2025-09-18 19:28:43 -0300 2975)         xgf_event_index = xgf_atomic_val_assign(0);
0000000000000 (Not Committed Yet 2025-09-18 19:28:43 -0300 2976)         atomic_set(&fstb_event_data_idx, 0);
0000000000000 (Not Committed Yet 2025-09-18 19:28:43 -0300 2977)         xgf_ko_enabled = xgf_atomic_val_assign(1);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2978) 
0000000000000 (Not Committed Yet 2025-09-18 19:28:43 -0300 2979)         xgf_stat_xchg_fp = xgf_stat_xchg;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2980) 
0000000000000 (Not Committed Yet 2025-09-18 19:28:43 -0300 2981)         /* --- ESTA  A LINHA CRUCIAL QUE FALTAVA --- */
0000000000000 (Not Committed Yet 2025-09-18 19:28:43 -0300 2982)         xgf_est_runtime_fp = xgff_est_runtime_fp;
0000000000000 (Not Committed Yet 2025-09-18 19:28:43 -0300 2983)         /* ------------------------------------------- */
0000000000000 (Not Committed Yet 2025-09-18 19:28:43 -0300 2984) 
0000000000000 (Not Committed Yet 2025-09-18 19:28:43 -0300 2985)         return 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2986) }
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2987) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2988) static KOBJ_ATTR_RO(deplist);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2989) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2990) int __init init_xgf(void)
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2991) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2992) 	init_xgf_ko();
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2993) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2994) 	if (!fpsgo_sysfs_create_dir(NULL, "xgf", &xgf_kobj)) {
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2995) 		fpsgo_sysfs_create_file(xgf_kobj, &kobj_attr_deplist);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2996) 		fpsgo_sysfs_create_file(xgf_kobj, &kobj_attr_xgf_spid_list);
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2997) 	}
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2998) 
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 2999) 	return 0;
d33644e354eaa (rsuntk            2025-03-12 16:57:08 +0000 3000) }
